/*
 * FlexMaestro Service
 * This is a basic FlexMaestro service, showcasing many features of a standard Twilio Service
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: your-team-name@twilio.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.twilio.flexmaestro.client.api.hello.message;

import com.twilio.core.jersey3.auth.annotations.ApiAuth;
import com.twilio.core.security.contexts.ApiAuthContext;
import com.twilio.flexmaestro.client.definitions.HelloMessage;
import com.twilio.flexmaestro.client.definitions.HelloMessageContainer;
import com.twilio.flexmaestro.client.definitions.HelloMessageList;
import com.twilio.rest.TwilioServiceErrorResponse;
import com.twilio.concurrency.limit.annotations.AIMDConcurrencyLimited;
import io.vavr.control.Either;
import com.twilio.sids.SmsSid;
import jakarta.ws.rs.container.AsyncResponse;
import com.twilio.core.request.context.RequestContext;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.twilio.platform.metrics.noop.NoopTwilioMetricRegistry;
import com.twilio.core.retry.policy.DefaultRetryPolicy;
import com.twilio.http.asyncv2.AsyncHttpClientBuilder;
import com.twilio.coreutil.resiliency.circuitbreaker.CircuitBreaker;
import com.twilio.coreutil.resiliency.circuitbreaker.NoopCircuitBreaker;
import com.twilio.coreutil.resiliency.circuitbreaker.config.CircuitBreakerConfig;
import com.twilio.coreutil.configuration.client.ClientConfiguration;
import com.twilio.core.util.transcoding.Transcoder;
import com.twilio.core.util.transcoding.TranscodingException;


import jakarta.validation.constraints.*;
import com.twilio.flexmaestro.client.api.Endpoint;
import com.twilio.flexmaestro.client.ClientRequestType;
import com.twilio.flexmaestro.client.NoopResponseHandler;
import com.twilio.flexmaestro.client.DefaultRequestHandlerProvider;
import com.twilio.flexmaestro.client.RequestHandlerProvider;
import com.twilio.flexmaestro.client.ParamSerializer;
import com.twilio.core.client.ahc.AbstractAhcServiceClientBuilder;
import com.twilio.coreutil.resiliency.circuitbreaker.CircuitBreaker;
import com.twilio.coreutil.resiliency.circuitbreaker.config.CircuitBreakerConfig;
import com.twilio.core.client.base.ServiceClient;
import com.twilio.core.client.base.call.CallBuilder;
import com.twilio.core.client.base.exceptions.ServiceResponseException;
import com.twilio.core.client.base.handlers.DefaultRequestHandler;
import com.twilio.core.client.base.id.ClientId;
import com.twilio.core.client.base.id.DefaultClientId;
import com.twilio.core.client.base.id.IdentifiableClient;
import com.twilio.core.client.base.metadata.DefaultMetadata;
import com.twilio.core.client.base.response.EncodedResponse;
import com.twilio.core.jackson.JacksonTranscoder;
import com.twilio.core.routing.URIServiceRouteResolver;
import com.twilio.core.util.UriBuilder;
import com.twilio.core.util.concurrent.Futures;
import com.twilio.core.util.transcoding.UrlencodedFormDataTranscoder;
import com.twilio.core.domain.ServiceError;
import com.twilio.core.domain.ErrorCode;
import com.twilio.rest.TwilioServiceErrorException;

import com.twilio.coreutil.ThreadFactoryImpl;
import com.twilio.json.JsonUtil;
import com.twilio.platform.metrics.TwilioMetricRegistry;
import com.twilio.platform.metrics.TwilioMeter;
import com.twilio.platform.metrics.TwilioTimer;

import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.nio.charset.StandardCharsets;
import java.io.IOException;

import com.twilio.coreutil.logging.MDCCompletableFuture;
import static com.twilio.coreutil.Exceptions.findNestedException;
import static com.twilio.coreutil.Futures.composeExceptionally;
import static java.util.Objects.requireNonNullElse;

import java.util.Objects;
import static java.util.Objects.equals;
import static java.util.Objects.hash;
import static java.util.Objects.nonNull;
import static java.util.Objects.requireNonNull;
import static java.util.Objects.isNull;
import static java.util.Objects.requireNonNullElse;

import com.twilio.core.request.context.RequestContext;
import com.twilio.core.security.principals.AuthenticatedAccount;
import com.twilio.core.security.principals.AuthenticatedUser;
import com.twilio.sids.HostSid;

import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.Optional;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.Executors;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;

/**
 * A client providing access to the following operations.
 *
 * <ul>
 * 
 * <li>createMessage</li>
 * <li>deleteMessage</li>
 * <li>getMessage</li>
 * <li>listMessages</li>
 * <li>updateMessage</li>
 * </ul>
 */

@jakarta.annotation.Generated(value = "com.twilio.codegen.TwilioGenerator", date = "2024-04-01T15:05:48.196693+05:30[Asia/Kolkata]")
public class HelloMessageClient implements IdentifiableClient {

    /**
   * Builder that produces HelloMessageClient instances.
   */
  public static class Builder extends AbstractAhcServiceClientBuilder<Builder> {
    private static final URI DEFAULT_BASE_URL = URI.create("http://localhost:9876/v1");
    private static final String DEFAULT_CLIENT_NAME = "flex-maestro-integration-tests-HelloMessageClient";
    private static final String CLIENT_VERSION = "1.0.0";
    private static final Set<Integer> shouldNotRetryOnStatusCode = Set.of(200, 201, 202, 204, 302, 400, 401, 402, 403, 404, 409, 410, 415, 422);

    private final ClientConfiguration clientConfiguration;
    private String clientName = DEFAULT_CLIENT_NAME;
    private String clientVersion = CLIENT_VERSION;
    private Optional<HostSid> hostSid = Optional.empty();
    private Optional<CircuitBreakerConfig> circuitBreakerConfig = Optional.empty();
    private TwilioMetricRegistry metricsRegistry;
    private ParamSerializer paramSerializer;

    /**
     * Create a new Builder using the specified <code>clientConfiguration</code>.
     *
     * @param clientConfiguration a {@link ClientConfiguration}
     */
    public Builder(final ClientConfiguration clientConfiguration) {
      tracing(true);
      this.clientConfiguration = clientConfiguration;
      if (clientConfiguration.getBaseUri() != null) {
        routeResolver(new URIServiceRouteResolver(clientConfiguration.getBaseUri()));
      }
      clientName = clientConfiguration.getClientName();
      clientVersion = clientConfiguration.getClientVersion();
      hostSid = Optional.ofNullable(clientConfiguration.getHostSid());
      circuitBreakerConfig  = Optional.ofNullable(clientConfiguration.getCircuitBreakerProperties());

      if (clientConfiguration.getConnectionProperties() != null) {
        // threadName is metricsPrefix or clientName or DEFAULT_CLIENT_NAME adding '-' at the end
        final var threadName = Optional.ofNullable(clientConfiguration.getMetricsPrefix())
            .orElse(Optional.ofNullable(clientName).orElse(DEFAULT_CLIENT_NAME)) + "-";
        client(new AsyncHttpClientBuilder(new ThreadFactoryImpl(threadName))
            .using(clientConfiguration.getConnectionProperties()).build());
      }

      retry(DefaultRetryPolicy.builder().retryIf(t -> {
          final var serviceResponseException = findExceptionByClass(t, ServiceResponseException.class);
          if (serviceResponseException != null) {
              return !shouldNotRetryOnStatusCode.contains(serviceResponseException.getStatusCode());
          }
          return false;
        }).build());
    }

    /**
     * Assign the client's {@link java.net.URI baseUrl}.
     *
     * @param baseUrl the {@link java.net.URI used as the common url}
     * @return the {@link Builder self }
     */
    public Builder baseUrl(final java.net.URI baseUrl) {
      routeResolver(new URIServiceRouteResolver(requireNonNull(baseUrl, "baseUrl is required")));
      return this;
    }

    /**
     * Assign the client's {@link String clientName}.
     *
     * @param clientName the {@link String name of the client}
     * @return the {@link Builder self}
     */
    public Builder clientName(final String clientName) {
      this.clientName = requireNonNull(clientName, "clientName is required");
      return this;
    }

    /**
     * Assign the client's {@link CircuitBreakerConfig circuitBreakerConfig}.
     *
     * @param circuitBreakerConfig the {@link CircuitBreakerConfig}
     * @return the {@link Builder self}
     */
    public Builder circuitBreakerConfig(final CircuitBreakerConfig circuitBreakerConfig) {
      this.circuitBreakerConfig = Optional.ofNullable(circuitBreakerConfig);
      return this;
    }

    /**
     * Assign the client's {@link TwilioMetricRegistry metricRegistry}.
     *
     * @param metricRegistry {@link TwilioMetricRegistry metrics registry}
     * @return the {@link Builder self}
     */
    public Builder metricsRegistry(final TwilioMetricRegistry metricRegistry) {
      this.metricsRegistry = metricRegistry;
      return this;
    }

    /**
     * Assign the client's {@link HostSid hostSid}.
     *
     * @param hostSid the {@link HostSid host SID}
     * @return the {@link Builder self}
     */
    public Builder hostSid(final HostSid hostSid) {
      this.hostSid = Optional.ofNullable(hostSid);
      return this;
    }

    /**
     * Assign the client's {@link ObjectMapper objectMapper}.
     *
     * @param objectMapper the {@link ObjectMapper}
     * @return the {@link Builder self}
     */
    public Builder objectMapper(final ObjectMapper objectMapper) {
      transcoder(new JacksonTranscoder(
        JsonUtil.configureJsonMapper(requireNonNull(objectMapper, "objectMapper is required"))));
        paramSerializer = ParamSerializer.getInstance(objectMapper);
      return this;
    }

    /**
     * Create a new {@link HelloMessageClient} instance.
     *
     * @return a new {@link HelloMessageClient}
     */
    public HelloMessageClient build() {
      if (isNull(this.routeResolver)) {
        routeResolver(new URIServiceRouteResolver(DEFAULT_BASE_URL));
      }

      if (isNull(this.clientId)) {
        clientId(new DefaultClientId(clientName, clientVersion, hostSid.orElse(null)));
      }

      if (isNull(this.metricsRegistry)) {
        metricsRegistry(new NoopTwilioMetricRegistry());
      }

      if (isNull(this.transcoder)) {
        transcoder(new JacksonTranscoder(JsonUtil.configureJsonMapper()));
      }

      if (isNull(this.paramSerializer)) {
         paramSerializer = ParamSerializer.getInstance(JsonUtil.configureJsonMapper());
      }

      return new HelloMessageClient(buildClient(),
        clientId,
        clientConfiguration,
        circuitBreakerConfig,
        metricsRegistry,
        paramSerializer);
    }

    private <T extends Throwable> T findExceptionByClass(final Throwable t, final Class<T> exceptionClass) {
      Throwable current = t;

      while (current != null) {
        if (exceptionClass.isInstance(current)) {
            return (T) current;
        }

        current = current.getCause();
      }

      return null;
    }
  }

    /**
   * Conditional requests are HTTP requests [RFC7231] that include one or more header fields
   * indicating a precondition to be tested before applying the method semantics to the target
   * resource. This document defines the HTTP/1.1 conditional request mechanisms in terms of the
   * architecture, syntax notation, and conformance criteria defined in [RFC7230].
   */
  public static class ConditionalRequest {
    /** The if-match request header field. */
    public static final String IF_MATCH = "If-Match";
    /** The if-none-match request header field. */
    public static final String IF_NONE_MATCH = "If-None-Match";
    /** The if-modified-since request header field. */
    public static final String IF_MODIFIED_SINCE = "If-Modified-Since";
    /** The if-unmodified-since request header field. */
    public static final String IF_UNMODIFIED_SINCE = "If-Unmodified-Since";
    /** The if-range request header field. */
    public static final String IF_RANGE = "If-Range";

    /**
     * Makes the request method conditional on the recipient origin server either having at least
     * one current representation of the target resource, when the field-value is '*', or having a
     * current representation of the target resource that has an entity-tag matching a member of the
     * list of entity-tags provided in the field-value.
     *
     * <p>Header name is 'If-Match'.
     */
    private final String ifMatch;

    /**
     * Makes the request method conditional on the selected representation's last modification date
     * being earlier than or equal to the date provided in the field-value.
     *
     * <p>Header name is 'If-Modified-Since'.
     */
    private final String ifModifiedSince;

    /**
     * Makes the request method conditional on the selected representation not having an entity-tag
     * matching any of the entity-tags provided in the field-value
     *
     * <p>Header name is 'If-None-Match'.
     */
    private final String ifNoneMatch;

    /**
     * Makes the request method conditional on the selected representation's last modification date
     * being later than the date provided in the field-value.
     *
     * <p>Header name is 'If-Unmodified-Since.'
     */
    private final String ifUnmodifiedSince;

    /**
     * The "If-Range" header field provides a special conditional request mechanism that is similar
     * to the If-Match and If-Unmodified-Since header fields but that instructs the recipient to
     * ignore the Range header field if the validator doesn't match, resulting in transfer of the
     * new selected representation instead of a 412 (Precondition Failed) response. If-Range is
     * defined in Section 3.2 of RFC7233.
     */
    private final String ifRange;

    /**
     * Constructor.
     *
     * @param ifMatch Makes the request method conditional on the recipient origin server either
     *     having at least one current representation of the target resource, when the field-value
     *     is *, or having a current representation of the target resource that has an entity-tag
     *     matching a member of the list of entity-tags provided in the field-value. a {@link
     *     String}
     * @param ifModifiedSince Makes the request method conditional on the selected representation's
     *     last modification date being earlier than or equal to the date provided in the
     *     field-value. a {@link String}
     * @param ifNoneMatch Makes the request method conditional on the selected representation not
     *     having an entity-tag matching any of the entity-tags provided in the field-value. a
     *     {@link String}
     * @param ifUnmodifiedSince Makes the request method conditional on the selected
     *     representation's last modification date being later than the date provided in the
     *     field-value. a {@link String}
     * @param ifRange is similar to the If-Match and If-Unmodified-Since header fields but that
     *     instructs the recipient to ignore the Range header field if the validator doesn't match,
     *     resulting in transfer of the new selected representation instead of a 412 (Precondition
     *     Failed) response.
     */
    public ConditionalRequest(
        final String ifMatch,
        final String ifModifiedSince,
        final String ifNoneMatch,
        final String ifUnmodifiedSince,
        final String ifRange) {
      this.ifMatch = ifMatch;
      this.ifModifiedSince = ifModifiedSince;
      this.ifNoneMatch = ifNoneMatch;
      this.ifUnmodifiedSince = ifUnmodifiedSince;
      this.ifRange = ifRange;
    }

    private ConditionalRequest(final Builder builder) {
      ifMatch = builder.ifMatch;
      ifModifiedSince = builder.ifModifiedSince;
      ifNoneMatch = builder.ifNoneMatch;
      ifUnmodifiedSince = builder.ifUnmodifiedSince;
      ifRange = builder.ifRange;
    }

    /**
      * Create a new Builder by cloning an existing ConditionalRequest.
      *
      * @param copy the ConditionalRequest to clone
      * @return a new Builder
      */
    public static Builder newBuilder(final ConditionalRequest copy) {
      Builder builder = new Builder();
      builder.ifMatch = copy.getIfMatch().orElse(null);
      builder.ifModifiedSince = copy.getIfModifiedSince().orElse(null);
      builder.ifNoneMatch = copy.getIfNoneMatch().orElse(null);
      builder.ifUnmodifiedSince = copy.getIfUnmodifiedSince().orElse(null);
      return builder;
    }

    /**
     * Set Request headers on the specified Endpoint.
     *
     * @param endpoint the endpoint to add the headers to
     */
    public void setHeaders(final Endpoint endpoint) {
      if (nonNull(ifMatch) && !ifMatch.isEmpty()) {
        endpoint.header(IF_MATCH, ifMatch);
      }

      if (nonNull(ifNoneMatch) && !ifNoneMatch.isEmpty()) {
        endpoint.header(IF_NONE_MATCH, ifNoneMatch);
      }

      if (nonNull(ifModifiedSince) && !ifModifiedSince.isEmpty()) {
        endpoint.header(IF_MODIFIED_SINCE, ifModifiedSince);
      }

      if (nonNull(ifUnmodifiedSince) && !ifUnmodifiedSince.isEmpty()) {
        endpoint.header(IF_UNMODIFIED_SINCE, ifUnmodifiedSince);
      }

      if (nonNull(ifRange) && !ifRange.isEmpty()) {
        endpoint.header(IF_RANGE, ifRange);
      }
    }

    /**
     * Get the value of the ifMatch property.
     *
     * @return an {@link Optional} of {@link String} representing the value of the ifMatch property
     */
    public Optional<String> getIfMatch() {
      return Optional.of(ifMatch);
    }

    /**
     * Get the value of the ifModifiedSince property.
     *
     * @return an {@link Optional} of {@link String} representing the value of the ifModifiedSince
     *     property
     */
    public Optional<String> getIfModifiedSince() {
      return Optional.of(ifModifiedSince);
    }

   /**
     * Get the value of the ifNoneMatch property.
     *
     * @return an {@link Optional} of {@link String} representing the value of the ifNoneMatch
     *     property
     */
    public Optional<String> getIfNoneMatch() {
      return Optional.of(ifNoneMatch);
    }

    /**
     * Get the value of the ifUnmodifiedSince property.
     *
     * @return an {@link Optional} of {@link String} representing the value of the ifUnmodifiedSince
     *     property
     */
    public Optional<String> getIfUnmodifiedSince() {
      return Optional.of(ifUnmodifiedSince);
    }

    /**
     * Get the value of the ifRange property.
     *
     * @return an {@link Optional} of {@link String} representing the value of the ifRange property
     */
    public Optional<String> getIfRange() {
      return Optional.of(ifRange);
    }

    @Override
    public boolean equals(final Object o) {
      if (this == o) return true;
      if (!(o instanceof ConditionalRequest)) return false;
      final ConditionalRequest that = (ConditionalRequest) o;
      return Objects.equals(ifMatch, that.ifMatch)
          && Objects.equals(ifModifiedSince, that.ifModifiedSince)
          && Objects.equals(ifNoneMatch, that.ifNoneMatch)
          && Objects.equals(ifUnmodifiedSince, that.ifUnmodifiedSince)
          && Objects.equals(ifRange, that.ifRange);
    }

    @Override
    public int hashCode() {
      return Objects.hash(ifMatch, ifModifiedSince, ifNoneMatch, ifUnmodifiedSince, ifRange);
    }

    @Override
    public String toString() {
      return "ConditionalRequest{"
          + "ifMatch='"
          + ifMatch
          + '\''
          + ", ifModifiedSince='"
          + ifModifiedSince
          + '\''
          + ", ifNoneMatch='"
          + ifNoneMatch
          + '\''
          + ", ifUnmodifiedSince='"
          + ifUnmodifiedSince
          + ", ifRange='"
          + ifRange
          + '\''
          + '}';
    }

    /** {@code ConditionalRequest} builder static inner class. */
    public static final class Builder {
      public String ifRange;
      private String ifMatch;
      private String ifModifiedSince;
      private String ifNoneMatch;
      private String ifUnmodifiedSince;

      private Builder() {}

      public static Builder newBuilder() {
        return new Builder();
      }

      /**
       * Sets the {@code ifMatch} and returns a reference to this Builder enabling method chaining.
       *
       * @param ifMatch the {@code ifMatch} to set
       * @return a reference to this Builder
       */
      public Builder withIfMatch(final String ifMatch) {
        this.ifMatch = ifMatch;
        return this;
      }

      /**
       * Sets the {@code ifModifiedSince} and returns a reference to this Builder enabling method
       * chaining.
       *
       * @param ifModifiedSince the {@code ifModifiedSince} to set
       * @return a reference to this Builder
       */
      public Builder withIfModifiedSince(final String ifModifiedSince) {
        this.ifModifiedSince = ifModifiedSince;
        return this;
      }

      /**
       * Sets the {@code ifNoneMatch} and returns a reference to this Builder enabling method
       * chaining.
       *
       * @param ifNoneMatch the {@code ifNoneMatch} to set
       * @return a reference to this Builder
       */
      public Builder withIfNoneMatch(final String ifNoneMatch) {
        this.ifNoneMatch = ifNoneMatch;
        return this;
      }

      /**
       * Sets the {@code ifUnmodifiedSince} and returns a reference to this Builder enabling method
       * chaining.
       *
       * @param ifUnmodifiedSince the {@code ifUnmodifiedSince} to set
       * @return a reference to this Builder
       */
      public Builder withIfUnmodifiedSince(final String ifUnmodifiedSince) {
        this.ifUnmodifiedSince = ifUnmodifiedSince;
        return this;
      }

      /**
       * Sets the {@code ifRange} and returns a reference to this Builder enabling method chaining.
       *
       * @param ifRange the {@code ifRange} to set
       * @return a reference to this Builder
       */
      public Builder withIfRange(final String ifRange) {
        this.ifRange = ifRange;
        return this;
      }

      /**
       * Returns a {@code ConditionalRequest} built from the parameters previously set.
       *
       * @return a {@code ConditionalRequest} built with parameters of this {@code
       *         ConditionalRequest.Builder}
       */
      public ConditionalRequest build() {
        return new ConditionalRequest(this);
      }
    }
  }

  

    // -------- Start CreateMessageCallBuilder --------

  /**
   * A type that is used to call the CreateMessage operation.
   */
    public final static class CreateMessageCallBuilder implements Endpoint {
        private static final String ENDPOINT_NAME = "create_message";
        private static final String ENDPOINT_PROJECT_NAME = "flex-maestro-integration-tests";
        private static final RequestHandlerProvider REQUEST_HANDLER_PROVIDER = new DefaultRequestHandlerProvider();
        private static final Set<String> REQUIRED_QUERY_PARAMS = Set.of();
        private static final Set<String> REQUIRED_HEADER_PARAMS = Set.of("etag");

        private static CircuitBreaker CIRCUIT_BREAKER;
        private static Metrics METRICS;

        private final ServiceClient serviceClient;
        private final UriBuilder uriBuilder;
        private final CircuitBreaker circuitBreaker;
        private final Metrics metrics;
        private final DefaultMetadata.Builder metadataBuilder;
        private final ParamSerializer paramSerializer;
        private final HelloMessageClient.CreateMessageResponseHeaders responseHeaders;
        private final Set<String> assignedQueryParams = new HashSet<>();
        private final Set<String> assignedHeaderParams = new HashSet<>();

    private final HelloMessage helloMessage;
        private final com.twilio.core.request.context.RequestContext requestContext;

        private CreateMessageCallBuilder(
            final ServiceClient serviceClient,
            final CircuitBreaker circuitBreaker,
            final Metrics metrics,
            final UriBuilder uriBuilder,
            final DefaultMetadata.Builder metadataBuilder,
            
        final HelloMessage helloMessage, 
            final HelloMessageClient.CreateMessageResponseHeaders responseHeaders,
            final com.twilio.core.request.context.RequestContext requestContext,
            final ParamSerializer paramSerializer) {

                this.serviceClient = serviceClient;
                this.uriBuilder = uriBuilder;
                this.metadataBuilder = metadataBuilder;
                this.helloMessage = helloMessage;
                this.requestContext = requestContext;
                this.circuitBreaker = circuitBreaker;
                this.metrics = metrics;
                this.paramSerializer = paramSerializer;
                this.responseHeaders = responseHeaders;

                requestContext.streamMetadata()
                    .filter(entry -> entry.getKey().toLowerCase(Locale.US).startsWith("t-")
                        || entry.getKey().toLowerCase(Locale.US).startsWith("i-twilio-"))
                    .forEach(entry -> this.metadataBuilder.add(entry.getKey(), entry.getValue()));
        }
    
        /**
     * Set &quot;etag&quot; parameter .
     *
     * @param etag assign etag a {@link String}
     * @return the {@link CreateMessageCallBuilder}
     */
    public CreateMessageCallBuilder etag(final String etag) {
      // ensure value isn't null, if null then do not add the parameter
      if (nonNull(etag)) { 
    header("etag", etag);
        assignedHeaderParams.add("etag");
      } else { 
        assignedHeaderParams.remove("etag");
      }
      return this;
    }
                
    
    /**
     * Set the header parameter with the <code>name</code> to the specified <code>value</code>.
     *
     * @param name the {@link String name} of the header field
     * @param value the {@link String value} to set or remove if value is an empty string
     * @return the {@link CreateMessageCallBuilder}
     */
    @Override
    public CreateMessageCallBuilder header(final String name, final Object value) {
        if (value instanceof String && ((String) value).isEmpty()) {
            this.metadataBuilder.remove(name);
        } else {
            this.metadataBuilder.add(name, paramSerializer.serialize(value));
        }
        return this;
    }

    /**
     * Calls CreateMessage.
     * 
     * @return the {@link CompletionStage} of an {@link Either} with {@link TwilioServiceErrorResponse left} and {@link HelloMessageContainer right}
     */
    public CompletionStage<HelloMessageContainer> call() { 

        checkParameters();
        metadataBuilder.add("Content-Type", "application/json");
        final CallBuilder<HelloMessage, EncodedResponse> builder = new CallBuilder<>("POST", uriBuilder.build(),
                "create_message", helloMessage,
                metadataBuilder.build(), serviceClient, REQUEST_HANDLER_PROVIDER.provideRequestHandler(ClientRequestType.JSON_BODY),
                NoopResponseHandler.INSTANCE);

        // Add requestSid from request context
        builder.requestSid(this.requestContext.getRequestSid());

        // If principal is available then add it to the request
        requestContext.getPrincipal().ifPresent(principal -> {
            if (principal instanceof AuthenticatedAccount) {
                builder.principal(((AuthenticatedAccount) principal).getSid());
            } else if (principal instanceof AuthenticatedUser) {
                builder.principal(((AuthenticatedUser) principal).getSid());
            }
        });

        try (final var ignore = metrics.getRequestTimer().time()) {
            metrics.markRequest();

            return handleError(withBreaker(builder))
                .thenCompose(
                      r -> create(r, serviceClient.getTranscoder(), responseHeaders)
                .thenApply(re -> {
                      metrics.markRequestSucceeded();
                      return re;
                }))                .whenComplete((r, t) -> {
                    if (t != null) {
                        metrics.markRequestFailed();
                }
            });
        }
    }

    @Override
    public String getOperationName() {
        return ENDPOINT_NAME;
    }

    @Override
    public String getOperationProject() {
      return ENDPOINT_PROJECT_NAME;
    }

    /**
     * Check that all required body|form, header and query parameters has been set.
     **/
    private void checkParameters() {
        
        if (isNull(helloMessage)) {
            throw new IllegalArgumentException("Required body parameter 'helloMessage' is not defined.");
        } if (!assignedHeaderParams.contains("etag")) {
            throw new IllegalArgumentException("Required header parameter 'etag' is not defined.");
        } 
    }

    private CompletionStage<EncodedResponse> handleError(
        final CompletionStage<? extends EncodedResponse> completionStage) {

        final var completableFuture = new MDCCompletableFuture<EncodedResponse>();
        completionStage.whenComplete((er, t) -> {
            if (t == null) {
                completableFuture.complete(er);
                return;
            }
            findNestedException(t, ServiceResponseException.class)
                .ifPresentOrElse(sre -> {
                    if (!isTextPlain(sre)) {
                        // map error service response exception to a non-exceptional future, so we can map it
                        completableFuture.complete(sre.getResponse());
                    } else {
                        completableFuture.completeExceptionally(handleTextPlainError(sre));
                    }
                },
                () -> {
                    // non-serviceResponseException
                    completableFuture.completeExceptionally(t);
                });
        });
        return completableFuture;
    }

    private ServiceResponseException handleTextPlainError(final ServiceResponseException sre) {
        // Add text/plain body to the ServiceError
        return sre.getResponse().getPayloadSource()
            .map(payloadSource -> {
                String errorMessage;
                try {
                    errorMessage = new String(payloadSource.createStream().readAllBytes(), StandardCharsets.UTF_8);
                } catch (final IOException e) {
                    errorMessage = "Unable to retrieve body of text/plain response";
                }

                final var serviceErrorBuilder = ServiceError.builder().message(errorMessage);
                if (isEnvoyCircuitBreaking(sre)) {
                    serviceErrorBuilder.code(ErrorCode.DOWNSTREAM_OVERLOADED);
                }
                return new ServiceResponseException(sre.getResponse(), serviceErrorBuilder.build());
          })
          .orElse(sre);
    }

    private boolean isEnvoyCircuitBreaking(final ServiceResponseException serviceResponseException) {
        return serviceResponseException.getResponse().getMetadata("x-envoy-overloaded")
            .map(Boolean::parseBoolean)
            .orElse(false);
    }

    private final boolean isTextPlain(final ServiceResponseException serviceResponseException) {
        return serviceResponseException.getResponse().getMetadata("content-type")
            .filter(s -> s.startsWith("text/plain")).isPresent();
    }

    private CompletionStage<HelloMessageContainer> create(final EncodedResponse response, final Transcoder transcoder,
    final HelloMessageClient.CreateMessageResponseHeaders responseHeaders) {
    
        // Populate response headers
        responseHeaders.addHeaders(paramSerializer, response);

        try {
            switch (response.getStatusCode()) {
            
            case 201: { 
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<HelloMessageContainer>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                return MDCCompletableFuture.completedFuture(value);
            }
            case 401: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 403: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 422: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 500: { 
                metrics.mark500Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 429: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }

            default:
                return MDCCompletableFuture.failedFuture(new ServiceResponseException(response));
            }
        } catch (final Exception e) {
            return MDCCompletableFuture.failedFuture(e);
        }
    }

    private CompletionStage<? extends EncodedResponse> withBreaker(final CallBuilder<HelloMessage, EncodedResponse> builder) {
        return circuitBreaker.decorate(() -> builder.call())
            .withFailurePredicate(encodedResponse -> {
                return encodedResponse.getStatusCode() >= 500;
            }).withIgnoreExceptionPredicate(throwable -> {
                  if (throwable instanceof ServiceResponseException) {
                        final var exception = (ServiceResponseException) throwable.getCause();
                        return exception.getResponse().getStatusCode() < 500;
                  }
                  return false;
        }).execute();
    }

    private static CircuitBreaker ensureBreaker(final Optional<CircuitBreakerConfig> circuitBreakerConfig,
        final Metrics metrics) {

        if (isNull(CIRCUIT_BREAKER)) {
            CIRCUIT_BREAKER = circuitBreakerConfig
                .map(config -> CircuitBreaker.builder()
                    .withCircuitBreakerConfig(config)
                    .withOnClose(metrics::markCircuitBreakerClosed)
                    .withOnHalfOpen(metrics::markCircuitBreakerHalfOpen)
                    .withOnOpen(metrics::markCircuitBreakerOpen)
                    .withName(ENDPOINT_NAME)
                    .build())
                .orElse(new NoopCircuitBreaker());
        }
        return CIRCUIT_BREAKER;
    }

    private static Metrics ensureMetrics(final TwilioMetricRegistry metricsRegistry, final String metricsPrefix) {
      if (isNull(METRICS)) {
            METRICS = new Metrics(metricsRegistry, metricsPrefix);
      }
      return METRICS;
    }

      /**
     * Metrics holder for CreateMessageCallBuilder.
     */
    static class Metrics {
      private final TwilioMeter request400s;
      private final TwilioMeter request500s;
      private final TwilioMeter requestFailed;
      private final TwilioMeter requestMeter;
      private final TwilioMeter requestSucceeded;
      private final TwilioTimer requestTimer;

      private final TwilioMeter cbClosed;
      private final TwilioMeter cbHalfOpen;
      private final TwilioMeter cbOpen;

      Metrics(final TwilioMetricRegistry metricRegistry, final String metricsPrefix) {
        final String prefix = requireNonNullElse(metricsPrefix, ENDPOINT_PROJECT_NAME);
        requestMeter = metricRegistry.meter(String.format("%s_%s_client_requests", prefix, ENDPOINT_NAME));
        requestFailed = metricRegistry.meter(String.format("%s_%s_client_requests_failed", prefix, ENDPOINT_NAME));
        requestSucceeded = metricRegistry.meter(String.format("%s_%s_client_requests_succeeded", prefix, ENDPOINT_NAME));
        requestTimer = metricRegistry.timer(String.format("%s_%s_client_requests_timer", prefix, ENDPOINT_NAME));
        request400s = metricRegistry.meter(String.format("%s_%s_client_requests_4XXs", prefix, ENDPOINT_NAME));
        request500s = metricRegistry.meter(String.format("%s_%s_client_requests_5XXs", prefix, ENDPOINT_NAME));

        // circuit breaker metrics
        cbClosed = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_closed", prefix, ENDPOINT_NAME));
        cbHalfOpen = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_half_open", prefix, ENDPOINT_NAME));
        cbOpen = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_open", prefix, ENDPOINT_NAME));
      }

      /**
       * Marks a 4xx response.
       */
      void mark400Response() {
        request400s.mark();
      }

      /**
       * Marks a 5xx response.
       */
      void mark500Response() {
        request500s.mark();
      }

      /**
       * Marks a failed request.
       */
      void markRequestFailed() {
        requestFailed.mark();
      }

      /**
       * Marks an attempted request.
       */
      void markRequest() {
        requestMeter.mark();
      }

      /**
       * Marks an attempted request.
       */
      void markRequestSucceeded() {
        requestSucceeded.mark();
      }

      /**
       * Get the request timer.
       *
       * @return the {@link TwilioTimer}
       */
      TwilioTimer getRequestTimer() {
        return requestTimer;
      }

      /**
       * Mark the closing of the circuit breaker.
       */
      void markCircuitBreakerClosed() {
        cbClosed.mark();
      }

      /**
       * Mark the half opening of the circuit breaker.
       */
      void markCircuitBreakerHalfOpen() {
        cbHalfOpen.mark();
      }

      /**
       * Mark the opening of the circuit breaker.
       */
      void markCircuitBreakerOpen() {
        cbOpen.mark();
      }
    }

  }
  // -------- End of CreateMessageCallBuilder --------
    /**
   * A type to provide strongly typed header variables from a {@link EncodedResponse response}.
   */
  public static final class CreateMessageResponseHeaders {
    
    /**
     * The etag header variable, of type String.
     */
    public String etag;
    /**
     * The xRateLimitConfig header variable, of type String.
     */
    public String xRateLimitConfig;
    /**
     * The xRateLimitLimit header variable, of type String.
     */
    public String xRateLimitLimit;
    /**
     * The xRateLimitRemaining header variable, of type Integer.
     */
    public Integer xRateLimitRemaining;

    
      /**
       * The etag response header, of type String.
       *
       * @return the etag response header
       */
      public Optional<String> getEtag() {
        return Optional.ofNullable(etag);
      }
      /**
       * The xRateLimitConfig response header, of type String.
       *
       * @return the X-Rate-Limit-Config response header
       */
      public Optional<String> getXRateLimitConfig() {
        return Optional.ofNullable(xRateLimitConfig);
      }
      /**
       * The xRateLimitLimit response header, of type String.
       *
       * @return the X-Rate-Limit-Limit response header
       */
      public Optional<String> getXRateLimitLimit() {
        return Optional.ofNullable(xRateLimitLimit);
      }
      /**
       * The xRateLimitRemaining response header, of type Integer.
       *
       * @return the X-Rate-Limit-Remaining response header
       */
      public Optional<Integer> getXRateLimitRemaining() {
        return Optional.ofNullable(xRateLimitRemaining);
      }

    /**
     * Default constructor.
     */
    public CreateMessageResponseHeaders() {
    }

    /**
     * Assigns properties from a {@link EncodedResponse response}.
     *
     * @param paramSerializer the {@link ParamSerializer paramSerializer} to use for deserialization
     * @param response the {@link EncodedResponse response} to extract properties from
     * @return the {@link EncodedResponse}
     */
    public EncodedResponse addHeaders(final ParamSerializer paramSerializer,
            final EncodedResponse response) { 
        response.getMetadata("etag").ifPresent(val -> this.etag = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Config").ifPresent(val -> this.xRateLimitConfig = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Limit").ifPresent(val -> this.xRateLimitLimit = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Remaining").ifPresent(val -> this.xRateLimitRemaining = paramSerializer.deserialize(val, Integer.class));
        return response;
      }
    }

  

    // -------- Start DeleteMessageCallBuilder --------

  /**
   * A type that is used to call the DeleteMessage operation.
   */
    public final static class DeleteMessageCallBuilder implements Endpoint {
        private static final String ENDPOINT_NAME = "delete_message";
        private static final String ENDPOINT_PROJECT_NAME = "flex-maestro-integration-tests";
        private static final RequestHandlerProvider REQUEST_HANDLER_PROVIDER = new DefaultRequestHandlerProvider();
        private static final Set<String> REQUIRED_QUERY_PARAMS = Set.of();
        private static final Set<String> REQUIRED_HEADER_PARAMS = Set.of();

        private static CircuitBreaker CIRCUIT_BREAKER;
        private static Metrics METRICS;

        private final ServiceClient serviceClient;
        private final UriBuilder uriBuilder;
        private final CircuitBreaker circuitBreaker;
        private final Metrics metrics;
        private final DefaultMetadata.Builder metadataBuilder;
        private final ParamSerializer paramSerializer;
        private final HelloMessageClient.DeleteMessageResponseHeaders responseHeaders;
        private final Set<String> assignedQueryParams = new HashSet<>();
        private final Set<String> assignedHeaderParams = new HashSet<>();

    
        private final com.twilio.core.request.context.RequestContext requestContext;

        private DeleteMessageCallBuilder(
            final ServiceClient serviceClient,
            final CircuitBreaker circuitBreaker,
            final Metrics metrics,
            final UriBuilder uriBuilder,
            final DefaultMetadata.Builder metadataBuilder,
            
            final HelloMessageClient.DeleteMessageResponseHeaders responseHeaders,
            final com.twilio.core.request.context.RequestContext requestContext,
            final ParamSerializer paramSerializer) {

                this.serviceClient = serviceClient;
                this.uriBuilder = uriBuilder;
                this.metadataBuilder = metadataBuilder;
                this.requestContext = requestContext;
                this.circuitBreaker = circuitBreaker;
                this.metrics = metrics;
                this.paramSerializer = paramSerializer;
                this.responseHeaders = responseHeaders;

                requestContext.streamMetadata()
                    .filter(entry -> entry.getKey().toLowerCase(Locale.US).startsWith("t-")
                        || entry.getKey().toLowerCase(Locale.US).startsWith("i-twilio-"))
                    .forEach(entry -> this.metadataBuilder.add(entry.getKey(), entry.getValue()));
        }
    
    
    /**
     * Set the header parameter with the <code>name</code> to the specified <code>value</code>.
     *
     * @param name the {@link String name} of the header field
     * @param value the {@link String value} to set or remove if value is an empty string
     * @return the {@link DeleteMessageCallBuilder}
     */
    @Override
    public DeleteMessageCallBuilder header(final String name, final Object value) {
        if (value instanceof String && ((String) value).isEmpty()) {
            this.metadataBuilder.remove(name);
        } else {
            this.metadataBuilder.add(name, paramSerializer.serialize(value));
        }
        return this;
    }

    /**
     * Calls DeleteMessage.
     * 
     * @return the {@link CompletionStage} of an {@link Either} with {@link TwilioServiceErrorResponse left} and {@link Void right}
     */
    public CompletionStage<Void> call() { 

        checkParameters();
        metadataBuilder.add("Content-Type", "application/json; charset=utf-8");
        final CallBuilder<Void, EncodedResponse> builder = new CallBuilder<>("DELETE", uriBuilder.build(),
                "delete_message", null,
                metadataBuilder.build(), serviceClient, new DefaultRequestHandler(),
                NoopResponseHandler.INSTANCE);

        // Add requestSid from request context
        builder.requestSid(this.requestContext.getRequestSid());

        // If principal is available then add it to the request
        requestContext.getPrincipal().ifPresent(principal -> {
            if (principal instanceof AuthenticatedAccount) {
                builder.principal(((AuthenticatedAccount) principal).getSid());
            } else if (principal instanceof AuthenticatedUser) {
                builder.principal(((AuthenticatedUser) principal).getSid());
            }
        });

        try (final var ignore = metrics.getRequestTimer().time()) {
            metrics.markRequest();

            return handleError(withBreaker(builder))
                .thenCompose(
                      r -> create(r, serviceClient.getTranscoder(), responseHeaders)
                .thenApply(re -> {
                      metrics.markRequestSucceeded();
                      return re;
                }))                .whenComplete((r, t) -> {
                    if (t != null) {
                        metrics.markRequestFailed();
                }
            });
        }
    }

    @Override
    public String getOperationName() {
        return ENDPOINT_NAME;
    }

    @Override
    public String getOperationProject() {
      return ENDPOINT_PROJECT_NAME;
    }

    /**
     * Check that all required body|form, header and query parameters has been set.
     **/
    private void checkParameters() {
        
    }

    private CompletionStage<EncodedResponse> handleError(
        final CompletionStage<? extends EncodedResponse> completionStage) {

        final var completableFuture = new MDCCompletableFuture<EncodedResponse>();
        completionStage.whenComplete((er, t) -> {
            if (t == null) {
                completableFuture.complete(er);
                return;
            }
            findNestedException(t, ServiceResponseException.class)
                .ifPresentOrElse(sre -> {
                    if (!isTextPlain(sre)) {
                        // map error service response exception to a non-exceptional future, so we can map it
                        completableFuture.complete(sre.getResponse());
                    } else {
                        completableFuture.completeExceptionally(handleTextPlainError(sre));
                    }
                },
                () -> {
                    // non-serviceResponseException
                    completableFuture.completeExceptionally(t);
                });
        });
        return completableFuture;
    }

    private ServiceResponseException handleTextPlainError(final ServiceResponseException sre) {
        // Add text/plain body to the ServiceError
        return sre.getResponse().getPayloadSource()
            .map(payloadSource -> {
                String errorMessage;
                try {
                    errorMessage = new String(payloadSource.createStream().readAllBytes(), StandardCharsets.UTF_8);
                } catch (final IOException e) {
                    errorMessage = "Unable to retrieve body of text/plain response";
                }

                final var serviceErrorBuilder = ServiceError.builder().message(errorMessage);
                if (isEnvoyCircuitBreaking(sre)) {
                    serviceErrorBuilder.code(ErrorCode.DOWNSTREAM_OVERLOADED);
                }
                return new ServiceResponseException(sre.getResponse(), serviceErrorBuilder.build());
          })
          .orElse(sre);
    }

    private boolean isEnvoyCircuitBreaking(final ServiceResponseException serviceResponseException) {
        return serviceResponseException.getResponse().getMetadata("x-envoy-overloaded")
            .map(Boolean::parseBoolean)
            .orElse(false);
    }

    private final boolean isTextPlain(final ServiceResponseException serviceResponseException) {
        return serviceResponseException.getResponse().getMetadata("content-type")
            .filter(s -> s.startsWith("text/plain")).isPresent();
    }

    private CompletionStage<Void> create(final EncodedResponse response, final Transcoder transcoder,
    final HelloMessageClient.DeleteMessageResponseHeaders responseHeaders) {
    
        // Populate response headers
        responseHeaders.addHeaders(paramSerializer, response);

        try {
            switch (response.getStatusCode()) {
            
            case 204: { 
                Void value = null;
                return MDCCompletableFuture.completedFuture(value);
            }
            case 401: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type "));
                throw new TwilioServiceErrorException(value, response);
            }
            case 403: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type "));
                throw new TwilioServiceErrorException(value, response);
            }
            case 500: { 
                metrics.mark500Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type "));
                throw new TwilioServiceErrorException(value, response);
            }
            case 429: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type "));
                throw new TwilioServiceErrorException(value, response);
            }

            default:
                return MDCCompletableFuture.failedFuture(new ServiceResponseException(response));
            }
        } catch (final Exception e) {
            return MDCCompletableFuture.failedFuture(e);
        }
    }

    private CompletionStage<? extends EncodedResponse> withBreaker(final CallBuilder<Void, EncodedResponse> builder) {
        return circuitBreaker.decorate(() -> builder.call())
            .withFailurePredicate(encodedResponse -> {
                return encodedResponse.getStatusCode() >= 500;
            }).withIgnoreExceptionPredicate(throwable -> {
                  if (throwable instanceof ServiceResponseException) {
                        final var exception = (ServiceResponseException) throwable.getCause();
                        return exception.getResponse().getStatusCode() < 500;
                  }
                  return false;
        }).execute();
    }

    private static CircuitBreaker ensureBreaker(final Optional<CircuitBreakerConfig> circuitBreakerConfig,
        final Metrics metrics) {

        if (isNull(CIRCUIT_BREAKER)) {
            CIRCUIT_BREAKER = circuitBreakerConfig
                .map(config -> CircuitBreaker.builder()
                    .withCircuitBreakerConfig(config)
                    .withOnClose(metrics::markCircuitBreakerClosed)
                    .withOnHalfOpen(metrics::markCircuitBreakerHalfOpen)
                    .withOnOpen(metrics::markCircuitBreakerOpen)
                    .withName(ENDPOINT_NAME)
                    .build())
                .orElse(new NoopCircuitBreaker());
        }
        return CIRCUIT_BREAKER;
    }

    private static Metrics ensureMetrics(final TwilioMetricRegistry metricsRegistry, final String metricsPrefix) {
      if (isNull(METRICS)) {
            METRICS = new Metrics(metricsRegistry, metricsPrefix);
      }
      return METRICS;
    }

      /**
     * Metrics holder for DeleteMessageCallBuilder.
     */
    static class Metrics {
      private final TwilioMeter request400s;
      private final TwilioMeter request500s;
      private final TwilioMeter requestFailed;
      private final TwilioMeter requestMeter;
      private final TwilioMeter requestSucceeded;
      private final TwilioTimer requestTimer;

      private final TwilioMeter cbClosed;
      private final TwilioMeter cbHalfOpen;
      private final TwilioMeter cbOpen;

      Metrics(final TwilioMetricRegistry metricRegistry, final String metricsPrefix) {
        final String prefix = requireNonNullElse(metricsPrefix, ENDPOINT_PROJECT_NAME);
        requestMeter = metricRegistry.meter(String.format("%s_%s_client_requests", prefix, ENDPOINT_NAME));
        requestFailed = metricRegistry.meter(String.format("%s_%s_client_requests_failed", prefix, ENDPOINT_NAME));
        requestSucceeded = metricRegistry.meter(String.format("%s_%s_client_requests_succeeded", prefix, ENDPOINT_NAME));
        requestTimer = metricRegistry.timer(String.format("%s_%s_client_requests_timer", prefix, ENDPOINT_NAME));
        request400s = metricRegistry.meter(String.format("%s_%s_client_requests_4XXs", prefix, ENDPOINT_NAME));
        request500s = metricRegistry.meter(String.format("%s_%s_client_requests_5XXs", prefix, ENDPOINT_NAME));

        // circuit breaker metrics
        cbClosed = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_closed", prefix, ENDPOINT_NAME));
        cbHalfOpen = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_half_open", prefix, ENDPOINT_NAME));
        cbOpen = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_open", prefix, ENDPOINT_NAME));
      }

      /**
       * Marks a 4xx response.
       */
      void mark400Response() {
        request400s.mark();
      }

      /**
       * Marks a 5xx response.
       */
      void mark500Response() {
        request500s.mark();
      }

      /**
       * Marks a failed request.
       */
      void markRequestFailed() {
        requestFailed.mark();
      }

      /**
       * Marks an attempted request.
       */
      void markRequest() {
        requestMeter.mark();
      }

      /**
       * Marks an attempted request.
       */
      void markRequestSucceeded() {
        requestSucceeded.mark();
      }

      /**
       * Get the request timer.
       *
       * @return the {@link TwilioTimer}
       */
      TwilioTimer getRequestTimer() {
        return requestTimer;
      }

      /**
       * Mark the closing of the circuit breaker.
       */
      void markCircuitBreakerClosed() {
        cbClosed.mark();
      }

      /**
       * Mark the half opening of the circuit breaker.
       */
      void markCircuitBreakerHalfOpen() {
        cbHalfOpen.mark();
      }

      /**
       * Mark the opening of the circuit breaker.
       */
      void markCircuitBreakerOpen() {
        cbOpen.mark();
      }
    }

  }
  // -------- End of DeleteMessageCallBuilder --------
    /**
   * A type to provide strongly typed header variables from a {@link EncodedResponse response}.
   */
  public static final class DeleteMessageResponseHeaders {
    
    /**
     * The xRateLimitConfig header variable, of type String.
     */
    public String xRateLimitConfig;
    /**
     * The xRateLimitLimit header variable, of type String.
     */
    public String xRateLimitLimit;
    /**
     * The xRateLimitRemaining header variable, of type Integer.
     */
    public Integer xRateLimitRemaining;

    
      /**
       * The xRateLimitConfig response header, of type String.
       *
       * @return the X-Rate-Limit-Config response header
       */
      public Optional<String> getXRateLimitConfig() {
        return Optional.ofNullable(xRateLimitConfig);
      }
      /**
       * The xRateLimitLimit response header, of type String.
       *
       * @return the X-Rate-Limit-Limit response header
       */
      public Optional<String> getXRateLimitLimit() {
        return Optional.ofNullable(xRateLimitLimit);
      }
      /**
       * The xRateLimitRemaining response header, of type Integer.
       *
       * @return the X-Rate-Limit-Remaining response header
       */
      public Optional<Integer> getXRateLimitRemaining() {
        return Optional.ofNullable(xRateLimitRemaining);
      }

    /**
     * Default constructor.
     */
    public DeleteMessageResponseHeaders() {
    }

    /**
     * Assigns properties from a {@link EncodedResponse response}.
     *
     * @param paramSerializer the {@link ParamSerializer paramSerializer} to use for deserialization
     * @param response the {@link EncodedResponse response} to extract properties from
     * @return the {@link EncodedResponse}
     */
    public EncodedResponse addHeaders(final ParamSerializer paramSerializer,
            final EncodedResponse response) { 
        response.getMetadata("X-Rate-Limit-Config").ifPresent(val -> this.xRateLimitConfig = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Limit").ifPresent(val -> this.xRateLimitLimit = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Remaining").ifPresent(val -> this.xRateLimitRemaining = paramSerializer.deserialize(val, Integer.class));
        return response;
      }
    }

  

    // -------- Start GetMessageCallBuilder --------

  /**
   * A type that is used to call the GetMessage operation.
   */
    public final static class GetMessageCallBuilder implements Endpoint {
        private static final String ENDPOINT_NAME = "get_message";
        private static final String ENDPOINT_PROJECT_NAME = "flex-maestro-integration-tests";
        private static final RequestHandlerProvider REQUEST_HANDLER_PROVIDER = new DefaultRequestHandlerProvider();
        private static final Set<String> REQUIRED_QUERY_PARAMS = Set.of();
        private static final Set<String> REQUIRED_HEADER_PARAMS = Set.of("ifMatch", "ifModifiedSince", "ifNoneMatch", "ifUnmodifiedSince", "ifRange");

        private static CircuitBreaker CIRCUIT_BREAKER;
        private static Metrics METRICS;

        private final ServiceClient serviceClient;
        private final UriBuilder uriBuilder;
        private final CircuitBreaker circuitBreaker;
        private final Metrics metrics;
        private final DefaultMetadata.Builder metadataBuilder;
        private final ParamSerializer paramSerializer;
        private final HelloMessageClient.GetMessageResponseHeaders responseHeaders;
        private final Set<String> assignedQueryParams = new HashSet<>();
        private final Set<String> assignedHeaderParams = new HashSet<>();
        private ConditionalRequest conditional;

    
        private final com.twilio.core.request.context.RequestContext requestContext;

        private GetMessageCallBuilder(
            final ServiceClient serviceClient,
            final CircuitBreaker circuitBreaker,
            final Metrics metrics,
            final UriBuilder uriBuilder,
            final DefaultMetadata.Builder metadataBuilder,
            
            final HelloMessageClient.GetMessageResponseHeaders responseHeaders,
            final com.twilio.core.request.context.RequestContext requestContext,
            final ParamSerializer paramSerializer) {

                this.serviceClient = serviceClient;
                this.uriBuilder = uriBuilder;
                this.metadataBuilder = metadataBuilder;
                this.requestContext = requestContext;
                this.circuitBreaker = circuitBreaker;
                this.metrics = metrics;
                this.paramSerializer = paramSerializer;
                this.responseHeaders = responseHeaders;

                requestContext.streamMetadata()
                    .filter(entry -> entry.getKey().toLowerCase(Locale.US).startsWith("t-")
                        || entry.getKey().toLowerCase(Locale.US).startsWith("i-twilio-"))
                    .forEach(entry -> this.metadataBuilder.add(entry.getKey(), entry.getValue()));
        }
    
    
    /**
     * Since this is a conditional request, set the conditional request container.
     *
     * @param conditional the {@link ConditionalRequest} container
     * @return the {@link GetMessageCallBuilder}
     */
    public GetMessageCallBuilder conditional(final ConditionalRequest conditional) {
        this.conditional = conditional;
        return this;
    }
    /**
     * Set the header parameter with the <code>name</code> to the specified <code>value</code>.
     *
     * @param name the {@link String name} of the header field
     * @param value the {@link String value} to set or remove if value is an empty string
     * @return the {@link GetMessageCallBuilder}
     */
    @Override
    public GetMessageCallBuilder header(final String name, final Object value) {
        if (value instanceof String && ((String) value).isEmpty()) {
            this.metadataBuilder.remove(name);
        } else {
            this.metadataBuilder.add(name, paramSerializer.serialize(value));
        }
        return this;
    }

    /**
     * Calls GetMessage.
     * 
     * @return the {@link CompletionStage} of an {@link Either} with {@link TwilioServiceErrorResponse left} and {@link HelloMessageContainer right}
     */
    public CompletionStage<HelloMessageContainer> call() { 
        // assign conditional request headers
        conditional.setHeaders(this);

        checkParameters();
        metadataBuilder.add("Content-Type", "application/json; charset=utf-8");
        final CallBuilder<Void, EncodedResponse> builder = new CallBuilder<>("GET", uriBuilder.build(),
                "get_message", null,
                metadataBuilder.build(), serviceClient, new DefaultRequestHandler(),
                NoopResponseHandler.INSTANCE);

        // Add requestSid from request context
        builder.requestSid(this.requestContext.getRequestSid());

        // If principal is available then add it to the request
        requestContext.getPrincipal().ifPresent(principal -> {
            if (principal instanceof AuthenticatedAccount) {
                builder.principal(((AuthenticatedAccount) principal).getSid());
            } else if (principal instanceof AuthenticatedUser) {
                builder.principal(((AuthenticatedUser) principal).getSid());
            }
        });

        try (final var ignore = metrics.getRequestTimer().time()) {
            metrics.markRequest();

            return handleError(withBreaker(builder))
                .thenCompose(
                      r -> create(r, serviceClient.getTranscoder(), responseHeaders)
                .thenApply(re -> {
                      metrics.markRequestSucceeded();
                      return re;
                }))                .whenComplete((r, t) -> {
                    if (t != null) {
                        metrics.markRequestFailed();
                }
            });
        }
    }

    @Override
    public String getOperationName() {
        return ENDPOINT_NAME;
    }

    @Override
    public String getOperationProject() {
      return ENDPOINT_PROJECT_NAME;
    }

    /**
     * Check that all required body|form, header and query parameters has been set.
     **/
    private void checkParameters() {
        
    }

    private CompletionStage<EncodedResponse> handleError(
        final CompletionStage<? extends EncodedResponse> completionStage) {

        final var completableFuture = new MDCCompletableFuture<EncodedResponse>();
        completionStage.whenComplete((er, t) -> {
            if (t == null) {
                completableFuture.complete(er);
                return;
            }
            findNestedException(t, ServiceResponseException.class)
                .ifPresentOrElse(sre -> {
                    if (!isTextPlain(sre)) {
                        // map error service response exception to a non-exceptional future, so we can map it
                        completableFuture.complete(sre.getResponse());
                    } else {
                        completableFuture.completeExceptionally(handleTextPlainError(sre));
                    }
                },
                () -> {
                    // non-serviceResponseException
                    completableFuture.completeExceptionally(t);
                });
        });
        return completableFuture;
    }

    private ServiceResponseException handleTextPlainError(final ServiceResponseException sre) {
        // Add text/plain body to the ServiceError
        return sre.getResponse().getPayloadSource()
            .map(payloadSource -> {
                String errorMessage;
                try {
                    errorMessage = new String(payloadSource.createStream().readAllBytes(), StandardCharsets.UTF_8);
                } catch (final IOException e) {
                    errorMessage = "Unable to retrieve body of text/plain response";
                }

                final var serviceErrorBuilder = ServiceError.builder().message(errorMessage);
                if (isEnvoyCircuitBreaking(sre)) {
                    serviceErrorBuilder.code(ErrorCode.DOWNSTREAM_OVERLOADED);
                }
                return new ServiceResponseException(sre.getResponse(), serviceErrorBuilder.build());
          })
          .orElse(sre);
    }

    private boolean isEnvoyCircuitBreaking(final ServiceResponseException serviceResponseException) {
        return serviceResponseException.getResponse().getMetadata("x-envoy-overloaded")
            .map(Boolean::parseBoolean)
            .orElse(false);
    }

    private final boolean isTextPlain(final ServiceResponseException serviceResponseException) {
        return serviceResponseException.getResponse().getMetadata("content-type")
            .filter(s -> s.startsWith("text/plain")).isPresent();
    }

    private CompletionStage<HelloMessageContainer> create(final EncodedResponse response, final Transcoder transcoder,
    final HelloMessageClient.GetMessageResponseHeaders responseHeaders) {
    
        // Populate response headers
        responseHeaders.addHeaders(paramSerializer, response);

        try {
            switch (response.getStatusCode()) {
            
            case 200: { 
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<HelloMessageContainer>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                return MDCCompletableFuture.completedFuture(value);
            }
            case 401: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 403: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 404: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 500: { 
                metrics.mark500Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 429: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 304: { 
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<HelloMessageContainer>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                return MDCCompletableFuture.completedFuture(value);
            }

            default:
                return MDCCompletableFuture.failedFuture(new ServiceResponseException(response));
            }
        } catch (final Exception e) {
            return MDCCompletableFuture.failedFuture(e);
        }
    }

    private CompletionStage<? extends EncodedResponse> withBreaker(final CallBuilder<Void, EncodedResponse> builder) {
        return circuitBreaker.decorate(() -> builder.call())
            .withFailurePredicate(encodedResponse -> {
                return encodedResponse.getStatusCode() >= 500;
            }).withIgnoreExceptionPredicate(throwable -> {
                  if (throwable instanceof ServiceResponseException) {
                        final var exception = (ServiceResponseException) throwable.getCause();
                        return exception.getResponse().getStatusCode() < 500;
                  }
                  return false;
        }).execute();
    }

    private static CircuitBreaker ensureBreaker(final Optional<CircuitBreakerConfig> circuitBreakerConfig,
        final Metrics metrics) {

        if (isNull(CIRCUIT_BREAKER)) {
            CIRCUIT_BREAKER = circuitBreakerConfig
                .map(config -> CircuitBreaker.builder()
                    .withCircuitBreakerConfig(config)
                    .withOnClose(metrics::markCircuitBreakerClosed)
                    .withOnHalfOpen(metrics::markCircuitBreakerHalfOpen)
                    .withOnOpen(metrics::markCircuitBreakerOpen)
                    .withName(ENDPOINT_NAME)
                    .build())
                .orElse(new NoopCircuitBreaker());
        }
        return CIRCUIT_BREAKER;
    }

    private static Metrics ensureMetrics(final TwilioMetricRegistry metricsRegistry, final String metricsPrefix) {
      if (isNull(METRICS)) {
            METRICS = new Metrics(metricsRegistry, metricsPrefix);
      }
      return METRICS;
    }

      /**
     * Metrics holder for GetMessageCallBuilder.
     */
    static class Metrics {
      private final TwilioMeter request400s;
      private final TwilioMeter request500s;
      private final TwilioMeter requestFailed;
      private final TwilioMeter requestMeter;
      private final TwilioMeter requestSucceeded;
      private final TwilioTimer requestTimer;

      private final TwilioMeter cbClosed;
      private final TwilioMeter cbHalfOpen;
      private final TwilioMeter cbOpen;

      Metrics(final TwilioMetricRegistry metricRegistry, final String metricsPrefix) {
        final String prefix = requireNonNullElse(metricsPrefix, ENDPOINT_PROJECT_NAME);
        requestMeter = metricRegistry.meter(String.format("%s_%s_client_requests", prefix, ENDPOINT_NAME));
        requestFailed = metricRegistry.meter(String.format("%s_%s_client_requests_failed", prefix, ENDPOINT_NAME));
        requestSucceeded = metricRegistry.meter(String.format("%s_%s_client_requests_succeeded", prefix, ENDPOINT_NAME));
        requestTimer = metricRegistry.timer(String.format("%s_%s_client_requests_timer", prefix, ENDPOINT_NAME));
        request400s = metricRegistry.meter(String.format("%s_%s_client_requests_4XXs", prefix, ENDPOINT_NAME));
        request500s = metricRegistry.meter(String.format("%s_%s_client_requests_5XXs", prefix, ENDPOINT_NAME));

        // circuit breaker metrics
        cbClosed = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_closed", prefix, ENDPOINT_NAME));
        cbHalfOpen = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_half_open", prefix, ENDPOINT_NAME));
        cbOpen = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_open", prefix, ENDPOINT_NAME));
      }

      /**
       * Marks a 4xx response.
       */
      void mark400Response() {
        request400s.mark();
      }

      /**
       * Marks a 5xx response.
       */
      void mark500Response() {
        request500s.mark();
      }

      /**
       * Marks a failed request.
       */
      void markRequestFailed() {
        requestFailed.mark();
      }

      /**
       * Marks an attempted request.
       */
      void markRequest() {
        requestMeter.mark();
      }

      /**
       * Marks an attempted request.
       */
      void markRequestSucceeded() {
        requestSucceeded.mark();
      }

      /**
       * Get the request timer.
       *
       * @return the {@link TwilioTimer}
       */
      TwilioTimer getRequestTimer() {
        return requestTimer;
      }

      /**
       * Mark the closing of the circuit breaker.
       */
      void markCircuitBreakerClosed() {
        cbClosed.mark();
      }

      /**
       * Mark the half opening of the circuit breaker.
       */
      void markCircuitBreakerHalfOpen() {
        cbHalfOpen.mark();
      }

      /**
       * Mark the opening of the circuit breaker.
       */
      void markCircuitBreakerOpen() {
        cbOpen.mark();
      }
    }

  }
  // -------- End of GetMessageCallBuilder --------
    /**
   * A type to provide strongly typed header variables from a {@link EncodedResponse response}.
   */
  public static final class GetMessageResponseHeaders {
    
    /**
     * The etag header variable, of type String.
     */
    public String etag;
    /**
     * The xRateLimitConfig header variable, of type String.
     */
    public String xRateLimitConfig;
    /**
     * The xRateLimitLimit header variable, of type String.
     */
    public String xRateLimitLimit;
    /**
     * The xRateLimitRemaining header variable, of type Integer.
     */
    public Integer xRateLimitRemaining;
    /**
     * The eTag header variable, of type String.
     */
    public String eTag;
    /**
     * The cacheControl header variable, of type String.
     */
    public String cacheControl;
    /**
     * The contentLocation header variable, of type String.
     */
    public String contentLocation;
    /**
     * The dATE header variable, of type String.
     */
    public String dATE;
    /**
     * The expires header variable, of type String.
     */
    public String expires;
    /**
     * The vary header variable, of type String.
     */
    public String vary;
    /**
     * The lastModified header variable, of type String.
     */
    public String lastModified;

    
      /**
       * The etag response header, of type String.
       *
       * @return the etag response header
       */
      public Optional<String> getEtag() {
        return Optional.ofNullable(etag);
      }
      /**
       * The xRateLimitConfig response header, of type String.
       *
       * @return the X-Rate-Limit-Config response header
       */
      public Optional<String> getXRateLimitConfig() {
        return Optional.ofNullable(xRateLimitConfig);
      }
      /**
       * The xRateLimitLimit response header, of type String.
       *
       * @return the X-Rate-Limit-Limit response header
       */
      public Optional<String> getXRateLimitLimit() {
        return Optional.ofNullable(xRateLimitLimit);
      }
      /**
       * The xRateLimitRemaining response header, of type Integer.
       *
       * @return the X-Rate-Limit-Remaining response header
       */
      public Optional<Integer> getXRateLimitRemaining() {
        return Optional.ofNullable(xRateLimitRemaining);
      }
      /**
       * The eTag response header, of type String.
       *
       * @return the ETag response header
       */
      public Optional<String> getETag() {
        return Optional.ofNullable(eTag);
      }
      /**
       * The cacheControl response header, of type String.
       *
       * @return the Cache-Control response header
       */
      public Optional<String> getCacheControl() {
        return Optional.ofNullable(cacheControl);
      }
      /**
       * The contentLocation response header, of type String.
       *
       * @return the Content-Location response header
       */
      public Optional<String> getContentLocation() {
        return Optional.ofNullable(contentLocation);
      }
      /**
       * The dATE response header, of type String.
       *
       * @return the DATE response header
       */
      public Optional<String> getDATE() {
        return Optional.ofNullable(dATE);
      }
      /**
       * The expires response header, of type String.
       *
       * @return the Expires response header
       */
      public Optional<String> getExpires() {
        return Optional.ofNullable(expires);
      }
      /**
       * The vary response header, of type String.
       *
       * @return the Vary response header
       */
      public Optional<String> getVary() {
        return Optional.ofNullable(vary);
      }
      /**
       * The lastModified response header, of type String.
       *
       * @return the Last-Modified response header
       */
      public Optional<String> getLastModified() {
        return Optional.ofNullable(lastModified);
      }

    /**
     * Default constructor.
     */
    public GetMessageResponseHeaders() {
    }

    /**
     * Assigns properties from a {@link EncodedResponse response}.
     *
     * @param paramSerializer the {@link ParamSerializer paramSerializer} to use for deserialization
     * @param response the {@link EncodedResponse response} to extract properties from
     * @return the {@link EncodedResponse}
     */
    public EncodedResponse addHeaders(final ParamSerializer paramSerializer,
            final EncodedResponse response) { 
        response.getMetadata("etag").ifPresent(val -> this.etag = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Config").ifPresent(val -> this.xRateLimitConfig = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Limit").ifPresent(val -> this.xRateLimitLimit = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Remaining").ifPresent(val -> this.xRateLimitRemaining = paramSerializer.deserialize(val, Integer.class));
        response.getMetadata("ETag").ifPresent(val -> this.eTag = paramSerializer.deserialize(val, String.class));
        response.getMetadata("Cache-Control").ifPresent(val -> this.cacheControl = paramSerializer.deserialize(val, String.class));
        response.getMetadata("Content-Location").ifPresent(val -> this.contentLocation = paramSerializer.deserialize(val, String.class));
        response.getMetadata("DATE").ifPresent(val -> this.dATE = paramSerializer.deserialize(val, String.class));
        response.getMetadata("Expires").ifPresent(val -> this.expires = paramSerializer.deserialize(val, String.class));
        response.getMetadata("Vary").ifPresent(val -> this.vary = paramSerializer.deserialize(val, String.class));
        response.getMetadata("Last-Modified").ifPresent(val -> this.lastModified = paramSerializer.deserialize(val, String.class));
        return response;
      }
    }

  

    // -------- Start ListMessagesCallBuilder --------

  /**
   * A type that is used to call the ListMessages operation.
   */
    public final static class ListMessagesCallBuilder implements Endpoint {
        private static final String ENDPOINT_NAME = "list_messages";
        private static final String ENDPOINT_PROJECT_NAME = "flex-maestro-integration-tests";
        private static final RequestHandlerProvider REQUEST_HANDLER_PROVIDER = new DefaultRequestHandlerProvider();
        private static final Set<String> REQUIRED_QUERY_PARAMS = Set.of();
        private static final Set<String> REQUIRED_HEADER_PARAMS = Set.of();

        private static CircuitBreaker CIRCUIT_BREAKER;
        private static Metrics METRICS;

        private final ServiceClient serviceClient;
        private final UriBuilder uriBuilder;
        private final CircuitBreaker circuitBreaker;
        private final Metrics metrics;
        private final DefaultMetadata.Builder metadataBuilder;
        private final ParamSerializer paramSerializer;
        private final HelloMessageClient.ListMessagesResponseHeaders responseHeaders;
        private final Set<String> assignedQueryParams = new HashSet<>();
        private final Set<String> assignedHeaderParams = new HashSet<>();

    
        private final com.twilio.core.request.context.RequestContext requestContext;

        private ListMessagesCallBuilder(
            final ServiceClient serviceClient,
            final CircuitBreaker circuitBreaker,
            final Metrics metrics,
            final UriBuilder uriBuilder,
            final DefaultMetadata.Builder metadataBuilder,
            
            final HelloMessageClient.ListMessagesResponseHeaders responseHeaders,
            final com.twilio.core.request.context.RequestContext requestContext,
            final ParamSerializer paramSerializer) {

                this.serviceClient = serviceClient;
                this.uriBuilder = uriBuilder;
                this.metadataBuilder = metadataBuilder;
                this.requestContext = requestContext;
                this.circuitBreaker = circuitBreaker;
                this.metrics = metrics;
                this.paramSerializer = paramSerializer;
                this.responseHeaders = responseHeaders;

                requestContext.streamMetadata()
                    .filter(entry -> entry.getKey().toLowerCase(Locale.US).startsWith("t-")
                        || entry.getKey().toLowerCase(Locale.US).startsWith("i-twilio-"))
                    .forEach(entry -> this.metadataBuilder.add(entry.getKey(), entry.getValue()));
        }
    
        /**
     * Set &quot;from&quot; parameter .
     *
     * @param from A sender name  a {@link String}
     * @return the {@link ListMessagesCallBuilder}
     */
    public ListMessagesCallBuilder from(final String from) {
      // ensure value isn't null, if null then do not add the parameter
      if (nonNull(from)) { 
        this.uriBuilder.addQueryParam("From", paramSerializer.serialize(from));
        assignedQueryParams.add("from");
      } else { 
        assignedQueryParams.remove("from");
      }
      return this;
    }
                
        /**
     * Set &quot;to&quot; parameter .
     *
     * @param to A recipient name  a {@link String}
     * @return the {@link ListMessagesCallBuilder}
     */
    public ListMessagesCallBuilder to(final String to) {
      // ensure value isn't null, if null then do not add the parameter
      if (nonNull(to)) { 
        this.uriBuilder.addQueryParam("To", paramSerializer.serialize(to));
        assignedQueryParams.add("to");
      } else { 
        assignedQueryParams.remove("to");
      }
      return this;
    }
                
        /**
     * Set &quot;pageSize&quot; parameter .
     *
     * @param pageSize Number of results to return at once  a {@link Integer}
     * @return the {@link ListMessagesCallBuilder}
     */
    public ListMessagesCallBuilder pageSize(final Integer pageSize) {
      // ensure value isn't null, if null then do not add the parameter
      if (nonNull(pageSize)) { 
        this.uriBuilder.addQueryParam("PageSize", paramSerializer.serialize(pageSize));
        assignedQueryParams.add("pageSize");
      } else { 
        assignedQueryParams.remove("pageSize");
      }
      return this;
    }
                
        /**
     * Set &quot;pageToken&quot; parameter .
     *
     * @param pageToken Opaque token describing which page of results to return  a {@link String}
     * @return the {@link ListMessagesCallBuilder}
     */
    public ListMessagesCallBuilder pageToken(final String pageToken) {
      // ensure value isn't null, if null then do not add the parameter
      if (nonNull(pageToken)) { 
        this.uriBuilder.addQueryParam("PageToken", paramSerializer.serialize(pageToken));
        assignedQueryParams.add("pageToken");
      } else { 
        assignedQueryParams.remove("pageToken");
      }
      return this;
    }
                
    
    /**
     * Set the header parameter with the <code>name</code> to the specified <code>value</code>.
     *
     * @param name the {@link String name} of the header field
     * @param value the {@link String value} to set or remove if value is an empty string
     * @return the {@link ListMessagesCallBuilder}
     */
    @Override
    public ListMessagesCallBuilder header(final String name, final Object value) {
        if (value instanceof String && ((String) value).isEmpty()) {
            this.metadataBuilder.remove(name);
        } else {
            this.metadataBuilder.add(name, paramSerializer.serialize(value));
        }
        return this;
    }

    /**
     * Calls ListMessages.
     * 
     * @return the {@link CompletionStage} of an {@link Either} with {@link TwilioServiceErrorResponse left} and {@link HelloMessageList right}
     */
    public CompletionStage<HelloMessageList> call() { 

        checkParameters();
        metadataBuilder.add("Content-Type", "application/json; charset=utf-8");
        final CallBuilder<Void, EncodedResponse> builder = new CallBuilder<>("GET", uriBuilder.build(),
                "list_messages", null,
                metadataBuilder.build(), serviceClient, new DefaultRequestHandler(),
                NoopResponseHandler.INSTANCE);

        // Add requestSid from request context
        builder.requestSid(this.requestContext.getRequestSid());

        // If principal is available then add it to the request
        requestContext.getPrincipal().ifPresent(principal -> {
            if (principal instanceof AuthenticatedAccount) {
                builder.principal(((AuthenticatedAccount) principal).getSid());
            } else if (principal instanceof AuthenticatedUser) {
                builder.principal(((AuthenticatedUser) principal).getSid());
            }
        });

        try (final var ignore = metrics.getRequestTimer().time()) {
            metrics.markRequest();

            return handleError(withBreaker(builder))
                .thenCompose(
                      r -> create(r, serviceClient.getTranscoder(), responseHeaders)
                .thenApply(re -> {
                      metrics.markRequestSucceeded();
                      return re;
                }))                .whenComplete((r, t) -> {
                    if (t != null) {
                        metrics.markRequestFailed();
                }
            });
        }
    }

    @Override
    public String getOperationName() {
        return ENDPOINT_NAME;
    }

    @Override
    public String getOperationProject() {
      return ENDPOINT_PROJECT_NAME;
    }

    /**
     * Check that all required body|form, header and query parameters has been set.
     **/
    private void checkParameters() {
        
    }

    private CompletionStage<EncodedResponse> handleError(
        final CompletionStage<? extends EncodedResponse> completionStage) {

        final var completableFuture = new MDCCompletableFuture<EncodedResponse>();
        completionStage.whenComplete((er, t) -> {
            if (t == null) {
                completableFuture.complete(er);
                return;
            }
            findNestedException(t, ServiceResponseException.class)
                .ifPresentOrElse(sre -> {
                    if (!isTextPlain(sre)) {
                        // map error service response exception to a non-exceptional future, so we can map it
                        completableFuture.complete(sre.getResponse());
                    } else {
                        completableFuture.completeExceptionally(handleTextPlainError(sre));
                    }
                },
                () -> {
                    // non-serviceResponseException
                    completableFuture.completeExceptionally(t);
                });
        });
        return completableFuture;
    }

    private ServiceResponseException handleTextPlainError(final ServiceResponseException sre) {
        // Add text/plain body to the ServiceError
        return sre.getResponse().getPayloadSource()
            .map(payloadSource -> {
                String errorMessage;
                try {
                    errorMessage = new String(payloadSource.createStream().readAllBytes(), StandardCharsets.UTF_8);
                } catch (final IOException e) {
                    errorMessage = "Unable to retrieve body of text/plain response";
                }

                final var serviceErrorBuilder = ServiceError.builder().message(errorMessage);
                if (isEnvoyCircuitBreaking(sre)) {
                    serviceErrorBuilder.code(ErrorCode.DOWNSTREAM_OVERLOADED);
                }
                return new ServiceResponseException(sre.getResponse(), serviceErrorBuilder.build());
          })
          .orElse(sre);
    }

    private boolean isEnvoyCircuitBreaking(final ServiceResponseException serviceResponseException) {
        return serviceResponseException.getResponse().getMetadata("x-envoy-overloaded")
            .map(Boolean::parseBoolean)
            .orElse(false);
    }

    private final boolean isTextPlain(final ServiceResponseException serviceResponseException) {
        return serviceResponseException.getResponse().getMetadata("content-type")
            .filter(s -> s.startsWith("text/plain")).isPresent();
    }

    private CompletionStage<HelloMessageList> create(final EncodedResponse response, final Transcoder transcoder,
    final HelloMessageClient.ListMessagesResponseHeaders responseHeaders) {
    
        // Populate response headers
        responseHeaders.addHeaders(paramSerializer, response);

        try {
            switch (response.getStatusCode()) {
            
            case 200: { 
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<HelloMessageList>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageList"));
                return MDCCompletableFuture.completedFuture(value);
            }
            case 401: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageList"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 403: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageList"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 500: { 
                metrics.mark500Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageList"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 429: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageList"));
                throw new TwilioServiceErrorException(value, response);
            }

            default:
                return MDCCompletableFuture.failedFuture(new ServiceResponseException(response));
            }
        } catch (final Exception e) {
            return MDCCompletableFuture.failedFuture(e);
        }
    }

    private CompletionStage<? extends EncodedResponse> withBreaker(final CallBuilder<Void, EncodedResponse> builder) {
        return circuitBreaker.decorate(() -> builder.call())
            .withFailurePredicate(encodedResponse -> {
                return encodedResponse.getStatusCode() >= 500;
            }).withIgnoreExceptionPredicate(throwable -> {
                  if (throwable instanceof ServiceResponseException) {
                        final var exception = (ServiceResponseException) throwable.getCause();
                        return exception.getResponse().getStatusCode() < 500;
                  }
                  return false;
        }).execute();
    }

    private static CircuitBreaker ensureBreaker(final Optional<CircuitBreakerConfig> circuitBreakerConfig,
        final Metrics metrics) {

        if (isNull(CIRCUIT_BREAKER)) {
            CIRCUIT_BREAKER = circuitBreakerConfig
                .map(config -> CircuitBreaker.builder()
                    .withCircuitBreakerConfig(config)
                    .withOnClose(metrics::markCircuitBreakerClosed)
                    .withOnHalfOpen(metrics::markCircuitBreakerHalfOpen)
                    .withOnOpen(metrics::markCircuitBreakerOpen)
                    .withName(ENDPOINT_NAME)
                    .build())
                .orElse(new NoopCircuitBreaker());
        }
        return CIRCUIT_BREAKER;
    }

    private static Metrics ensureMetrics(final TwilioMetricRegistry metricsRegistry, final String metricsPrefix) {
      if (isNull(METRICS)) {
            METRICS = new Metrics(metricsRegistry, metricsPrefix);
      }
      return METRICS;
    }

      /**
     * Metrics holder for ListMessagesCallBuilder.
     */
    static class Metrics {
      private final TwilioMeter request400s;
      private final TwilioMeter request500s;
      private final TwilioMeter requestFailed;
      private final TwilioMeter requestMeter;
      private final TwilioMeter requestSucceeded;
      private final TwilioTimer requestTimer;

      private final TwilioMeter cbClosed;
      private final TwilioMeter cbHalfOpen;
      private final TwilioMeter cbOpen;

      Metrics(final TwilioMetricRegistry metricRegistry, final String metricsPrefix) {
        final String prefix = requireNonNullElse(metricsPrefix, ENDPOINT_PROJECT_NAME);
        requestMeter = metricRegistry.meter(String.format("%s_%s_client_requests", prefix, ENDPOINT_NAME));
        requestFailed = metricRegistry.meter(String.format("%s_%s_client_requests_failed", prefix, ENDPOINT_NAME));
        requestSucceeded = metricRegistry.meter(String.format("%s_%s_client_requests_succeeded", prefix, ENDPOINT_NAME));
        requestTimer = metricRegistry.timer(String.format("%s_%s_client_requests_timer", prefix, ENDPOINT_NAME));
        request400s = metricRegistry.meter(String.format("%s_%s_client_requests_4XXs", prefix, ENDPOINT_NAME));
        request500s = metricRegistry.meter(String.format("%s_%s_client_requests_5XXs", prefix, ENDPOINT_NAME));

        // circuit breaker metrics
        cbClosed = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_closed", prefix, ENDPOINT_NAME));
        cbHalfOpen = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_half_open", prefix, ENDPOINT_NAME));
        cbOpen = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_open", prefix, ENDPOINT_NAME));
      }

      /**
       * Marks a 4xx response.
       */
      void mark400Response() {
        request400s.mark();
      }

      /**
       * Marks a 5xx response.
       */
      void mark500Response() {
        request500s.mark();
      }

      /**
       * Marks a failed request.
       */
      void markRequestFailed() {
        requestFailed.mark();
      }

      /**
       * Marks an attempted request.
       */
      void markRequest() {
        requestMeter.mark();
      }

      /**
       * Marks an attempted request.
       */
      void markRequestSucceeded() {
        requestSucceeded.mark();
      }

      /**
       * Get the request timer.
       *
       * @return the {@link TwilioTimer}
       */
      TwilioTimer getRequestTimer() {
        return requestTimer;
      }

      /**
       * Mark the closing of the circuit breaker.
       */
      void markCircuitBreakerClosed() {
        cbClosed.mark();
      }

      /**
       * Mark the half opening of the circuit breaker.
       */
      void markCircuitBreakerHalfOpen() {
        cbHalfOpen.mark();
      }

      /**
       * Mark the opening of the circuit breaker.
       */
      void markCircuitBreakerOpen() {
        cbOpen.mark();
      }
    }

  }
  // -------- End of ListMessagesCallBuilder --------
    /**
   * A type to provide strongly typed header variables from a {@link EncodedResponse response}.
   */
  public static final class ListMessagesResponseHeaders {
    
    /**
     * The xRateLimitConfig header variable, of type String.
     */
    public String xRateLimitConfig;
    /**
     * The xRateLimitLimit header variable, of type String.
     */
    public String xRateLimitLimit;
    /**
     * The xRateLimitRemaining header variable, of type Integer.
     */
    public Integer xRateLimitRemaining;

    
      /**
       * The xRateLimitConfig response header, of type String.
       *
       * @return the X-Rate-Limit-Config response header
       */
      public Optional<String> getXRateLimitConfig() {
        return Optional.ofNullable(xRateLimitConfig);
      }
      /**
       * The xRateLimitLimit response header, of type String.
       *
       * @return the X-Rate-Limit-Limit response header
       */
      public Optional<String> getXRateLimitLimit() {
        return Optional.ofNullable(xRateLimitLimit);
      }
      /**
       * The xRateLimitRemaining response header, of type Integer.
       *
       * @return the X-Rate-Limit-Remaining response header
       */
      public Optional<Integer> getXRateLimitRemaining() {
        return Optional.ofNullable(xRateLimitRemaining);
      }

    /**
     * Default constructor.
     */
    public ListMessagesResponseHeaders() {
    }

    /**
     * Assigns properties from a {@link EncodedResponse response}.
     *
     * @param paramSerializer the {@link ParamSerializer paramSerializer} to use for deserialization
     * @param response the {@link EncodedResponse response} to extract properties from
     * @return the {@link EncodedResponse}
     */
    public EncodedResponse addHeaders(final ParamSerializer paramSerializer,
            final EncodedResponse response) { 
        response.getMetadata("X-Rate-Limit-Config").ifPresent(val -> this.xRateLimitConfig = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Limit").ifPresent(val -> this.xRateLimitLimit = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Remaining").ifPresent(val -> this.xRateLimitRemaining = paramSerializer.deserialize(val, Integer.class));
        return response;
      }
    }

  

    // -------- Start UpdateMessageCallBuilder --------

  /**
   * A type that is used to call the UpdateMessage operation.
   */
    public final static class UpdateMessageCallBuilder implements Endpoint {
        private static final String ENDPOINT_NAME = "update_message";
        private static final String ENDPOINT_PROJECT_NAME = "flex-maestro-integration-tests";
        private static final RequestHandlerProvider REQUEST_HANDLER_PROVIDER = new DefaultRequestHandlerProvider();
        private static final Set<String> REQUIRED_QUERY_PARAMS = Set.of();
        private static final Set<String> REQUIRED_HEADER_PARAMS = Set.of("ifMatch", "ifModifiedSince", "ifNoneMatch", "ifUnmodifiedSince", "ifRange");

        private static CircuitBreaker CIRCUIT_BREAKER;
        private static Metrics METRICS;

        private final ServiceClient serviceClient;
        private final UriBuilder uriBuilder;
        private final CircuitBreaker circuitBreaker;
        private final Metrics metrics;
        private final DefaultMetadata.Builder metadataBuilder;
        private final ParamSerializer paramSerializer;
        private final HelloMessageClient.UpdateMessageResponseHeaders responseHeaders;
        private final Set<String> assignedQueryParams = new HashSet<>();
        private final Set<String> assignedHeaderParams = new HashSet<>();
        private ConditionalRequest conditional;

    private final Map<String, Object> params = new java.util.HashMap<>();
        private final com.twilio.core.request.context.RequestContext requestContext;

        private UpdateMessageCallBuilder(
            final ServiceClient serviceClient,
            final CircuitBreaker circuitBreaker,
            final Metrics metrics,
            final UriBuilder uriBuilder,
            final DefaultMetadata.Builder metadataBuilder,
            
            final HelloMessageClient.UpdateMessageResponseHeaders responseHeaders,
            final com.twilio.core.request.context.RequestContext requestContext,
            final ParamSerializer paramSerializer) {

                this.serviceClient = serviceClient;
                this.uriBuilder = uriBuilder;
                this.metadataBuilder = metadataBuilder;
                this.requestContext = requestContext;
                this.circuitBreaker = circuitBreaker;
                this.metrics = metrics;
                this.paramSerializer = paramSerializer;
                this.responseHeaders = responseHeaders;

                requestContext.streamMetadata()
                    .filter(entry -> entry.getKey().toLowerCase(Locale.US).startsWith("t-")
                        || entry.getKey().toLowerCase(Locale.US).startsWith("i-twilio-"))
                    .forEach(entry -> this.metadataBuilder.add(entry.getKey(), entry.getValue()));
        }
    
        /**
     * Set &quot;from&quot; parameter .
     *
     * @param from Sender address  a {@link String}
     * @return the {@link UpdateMessageCallBuilder}
     */
    public UpdateMessageCallBuilder from(final String from) {
      // ensure value isn't null, if null then do not add the parameter
      if (nonNull(from)) { 
        this.params.put("From", paramSerializer.serialize(from));
      } else { 
      }
      return this;
    }
                
        /**
     * Set &quot;to&quot; parameter .
     *
     * @param to Recipient address  a {@link String}
     * @return the {@link UpdateMessageCallBuilder}
     */
    public UpdateMessageCallBuilder to(final String to) {
      // ensure value isn't null, if null then do not add the parameter
      if (nonNull(to)) { 
        this.params.put("To", paramSerializer.serialize(to));
      } else { 
      }
      return this;
    }
                
        /**
     * Set &quot;message&quot; parameter .
     *
     * @param message Message body  a {@link String}
     * @return the {@link UpdateMessageCallBuilder}
     */
    public UpdateMessageCallBuilder message(final String message) {
      // ensure value isn't null, if null then do not add the parameter
      if (nonNull(message)) { 
        this.params.put("Message", paramSerializer.serialize(message));
      } else { 
      }
      return this;
    }
                
    
    /**
     * Since this is a conditional request, set the conditional request container.
     *
     * @param conditional the {@link ConditionalRequest} container
     * @return the {@link UpdateMessageCallBuilder}
     */
    public UpdateMessageCallBuilder conditional(final ConditionalRequest conditional) {
        this.conditional = conditional;
        return this;
    }
    /**
     * Set the header parameter with the <code>name</code> to the specified <code>value</code>.
     *
     * @param name the {@link String name} of the header field
     * @param value the {@link String value} to set or remove if value is an empty string
     * @return the {@link UpdateMessageCallBuilder}
     */
    @Override
    public UpdateMessageCallBuilder header(final String name, final Object value) {
        if (value instanceof String && ((String) value).isEmpty()) {
            this.metadataBuilder.remove(name);
        } else {
            this.metadataBuilder.add(name, paramSerializer.serialize(value));
        }
        return this;
    }

    /**
     * Calls UpdateMessage.
     * 
     * @return the {@link CompletionStage} of an {@link Either} with {@link TwilioServiceErrorResponse left} and {@link HelloMessageContainer right}
     */
    public CompletionStage<HelloMessageContainer> call() { 
        // assign conditional request headers
        conditional.setHeaders(this);

        checkParameters();
        metadataBuilder.add("Content-Type", "application/x-www-form-urlencoded");
        final CallBuilder<Map<String, Object>, EncodedResponse> builder = new CallBuilder<>("PUT", uriBuilder.build(),
                "update_message", params, 
                metadataBuilder.build(), serviceClient, REQUEST_HANDLER_PROVIDER.provideRequestHandler(ClientRequestType.FORM_PARAMS),
                NoopResponseHandler.INSTANCE);

        // Add requestSid from request context
        builder.requestSid(this.requestContext.getRequestSid());

        // If principal is available then add it to the request
        requestContext.getPrincipal().ifPresent(principal -> {
            if (principal instanceof AuthenticatedAccount) {
                builder.principal(((AuthenticatedAccount) principal).getSid());
            } else if (principal instanceof AuthenticatedUser) {
                builder.principal(((AuthenticatedUser) principal).getSid());
            }
        });

        try (final var ignore = metrics.getRequestTimer().time()) {
            metrics.markRequest();

            return handleError(withBreaker(builder))
                .thenCompose(
                      r -> create(r, serviceClient.getTranscoder(), responseHeaders)
                .thenApply(re -> {
                      metrics.markRequestSucceeded();
                      return re;
                }))                .whenComplete((r, t) -> {
                    if (t != null) {
                        metrics.markRequestFailed();
                }
            });
        }
    }

    @Override
    public String getOperationName() {
        return ENDPOINT_NAME;
    }

    @Override
    public String getOperationProject() {
      return ENDPOINT_PROJECT_NAME;
    }

    /**
     * Check that all required body|form, header and query parameters has been set.
     **/
    private void checkParameters() {
        
    }

    private CompletionStage<EncodedResponse> handleError(
        final CompletionStage<? extends EncodedResponse> completionStage) {

        final var completableFuture = new MDCCompletableFuture<EncodedResponse>();
        completionStage.whenComplete((er, t) -> {
            if (t == null) {
                completableFuture.complete(er);
                return;
            }
            findNestedException(t, ServiceResponseException.class)
                .ifPresentOrElse(sre -> {
                    if (!isTextPlain(sre)) {
                        // map error service response exception to a non-exceptional future, so we can map it
                        completableFuture.complete(sre.getResponse());
                    } else {
                        completableFuture.completeExceptionally(handleTextPlainError(sre));
                    }
                },
                () -> {
                    // non-serviceResponseException
                    completableFuture.completeExceptionally(t);
                });
        });
        return completableFuture;
    }

    private ServiceResponseException handleTextPlainError(final ServiceResponseException sre) {
        // Add text/plain body to the ServiceError
        return sre.getResponse().getPayloadSource()
            .map(payloadSource -> {
                String errorMessage;
                try {
                    errorMessage = new String(payloadSource.createStream().readAllBytes(), StandardCharsets.UTF_8);
                } catch (final IOException e) {
                    errorMessage = "Unable to retrieve body of text/plain response";
                }

                final var serviceErrorBuilder = ServiceError.builder().message(errorMessage);
                if (isEnvoyCircuitBreaking(sre)) {
                    serviceErrorBuilder.code(ErrorCode.DOWNSTREAM_OVERLOADED);
                }
                return new ServiceResponseException(sre.getResponse(), serviceErrorBuilder.build());
          })
          .orElse(sre);
    }

    private boolean isEnvoyCircuitBreaking(final ServiceResponseException serviceResponseException) {
        return serviceResponseException.getResponse().getMetadata("x-envoy-overloaded")
            .map(Boolean::parseBoolean)
            .orElse(false);
    }

    private final boolean isTextPlain(final ServiceResponseException serviceResponseException) {
        return serviceResponseException.getResponse().getMetadata("content-type")
            .filter(s -> s.startsWith("text/plain")).isPresent();
    }

    private CompletionStage<HelloMessageContainer> create(final EncodedResponse response, final Transcoder transcoder,
    final HelloMessageClient.UpdateMessageResponseHeaders responseHeaders) {
    
        // Populate response headers
        responseHeaders.addHeaders(paramSerializer, response);

        try {
            switch (response.getStatusCode()) {
            
            case 200: { 
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<HelloMessageContainer>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                return MDCCompletableFuture.completedFuture(value);
            }
            case 400: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 401: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 403: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 404: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 500: { 
                metrics.mark500Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 429: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 412: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageContainer"));
                throw new TwilioServiceErrorException(value, response);
            }

            default:
                return MDCCompletableFuture.failedFuture(new ServiceResponseException(response));
            }
        } catch (final Exception e) {
            return MDCCompletableFuture.failedFuture(e);
        }
    }

    private CompletionStage<? extends EncodedResponse> withBreaker(final CallBuilder<Map<String, Object>, EncodedResponse> builder) {
        return circuitBreaker.decorate(() -> builder.call())
            .withFailurePredicate(encodedResponse -> {
                return encodedResponse.getStatusCode() >= 500;
            }).withIgnoreExceptionPredicate(throwable -> {
                  if (throwable instanceof ServiceResponseException) {
                        final var exception = (ServiceResponseException) throwable.getCause();
                        return exception.getResponse().getStatusCode() < 500;
                  }
                  return false;
        }).execute();
    }

    private static CircuitBreaker ensureBreaker(final Optional<CircuitBreakerConfig> circuitBreakerConfig,
        final Metrics metrics) {

        if (isNull(CIRCUIT_BREAKER)) {
            CIRCUIT_BREAKER = circuitBreakerConfig
                .map(config -> CircuitBreaker.builder()
                    .withCircuitBreakerConfig(config)
                    .withOnClose(metrics::markCircuitBreakerClosed)
                    .withOnHalfOpen(metrics::markCircuitBreakerHalfOpen)
                    .withOnOpen(metrics::markCircuitBreakerOpen)
                    .withName(ENDPOINT_NAME)
                    .build())
                .orElse(new NoopCircuitBreaker());
        }
        return CIRCUIT_BREAKER;
    }

    private static Metrics ensureMetrics(final TwilioMetricRegistry metricsRegistry, final String metricsPrefix) {
      if (isNull(METRICS)) {
            METRICS = new Metrics(metricsRegistry, metricsPrefix);
      }
      return METRICS;
    }

      /**
     * Metrics holder for UpdateMessageCallBuilder.
     */
    static class Metrics {
      private final TwilioMeter request400s;
      private final TwilioMeter request500s;
      private final TwilioMeter requestFailed;
      private final TwilioMeter requestMeter;
      private final TwilioMeter requestSucceeded;
      private final TwilioTimer requestTimer;

      private final TwilioMeter cbClosed;
      private final TwilioMeter cbHalfOpen;
      private final TwilioMeter cbOpen;

      Metrics(final TwilioMetricRegistry metricRegistry, final String metricsPrefix) {
        final String prefix = requireNonNullElse(metricsPrefix, ENDPOINT_PROJECT_NAME);
        requestMeter = metricRegistry.meter(String.format("%s_%s_client_requests", prefix, ENDPOINT_NAME));
        requestFailed = metricRegistry.meter(String.format("%s_%s_client_requests_failed", prefix, ENDPOINT_NAME));
        requestSucceeded = metricRegistry.meter(String.format("%s_%s_client_requests_succeeded", prefix, ENDPOINT_NAME));
        requestTimer = metricRegistry.timer(String.format("%s_%s_client_requests_timer", prefix, ENDPOINT_NAME));
        request400s = metricRegistry.meter(String.format("%s_%s_client_requests_4XXs", prefix, ENDPOINT_NAME));
        request500s = metricRegistry.meter(String.format("%s_%s_client_requests_5XXs", prefix, ENDPOINT_NAME));

        // circuit breaker metrics
        cbClosed = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_closed", prefix, ENDPOINT_NAME));
        cbHalfOpen = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_half_open", prefix, ENDPOINT_NAME));
        cbOpen = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_open", prefix, ENDPOINT_NAME));
      }

      /**
       * Marks a 4xx response.
       */
      void mark400Response() {
        request400s.mark();
      }

      /**
       * Marks a 5xx response.
       */
      void mark500Response() {
        request500s.mark();
      }

      /**
       * Marks a failed request.
       */
      void markRequestFailed() {
        requestFailed.mark();
      }

      /**
       * Marks an attempted request.
       */
      void markRequest() {
        requestMeter.mark();
      }

      /**
       * Marks an attempted request.
       */
      void markRequestSucceeded() {
        requestSucceeded.mark();
      }

      /**
       * Get the request timer.
       *
       * @return the {@link TwilioTimer}
       */
      TwilioTimer getRequestTimer() {
        return requestTimer;
      }

      /**
       * Mark the closing of the circuit breaker.
       */
      void markCircuitBreakerClosed() {
        cbClosed.mark();
      }

      /**
       * Mark the half opening of the circuit breaker.
       */
      void markCircuitBreakerHalfOpen() {
        cbHalfOpen.mark();
      }

      /**
       * Mark the opening of the circuit breaker.
       */
      void markCircuitBreakerOpen() {
        cbOpen.mark();
      }
    }

  }
  // -------- End of UpdateMessageCallBuilder --------
    /**
   * A type to provide strongly typed header variables from a {@link EncodedResponse response}.
   */
  public static final class UpdateMessageResponseHeaders {
    
    /**
     * The xRateLimitConfig header variable, of type String.
     */
    public String xRateLimitConfig;
    /**
     * The xRateLimitLimit header variable, of type String.
     */
    public String xRateLimitLimit;
    /**
     * The xRateLimitRemaining header variable, of type Integer.
     */
    public Integer xRateLimitRemaining;
    /**
     * The eTag header variable, of type String.
     */
    public String eTag;
    /**
     * The lastModified header variable, of type String.
     */
    public String lastModified;

    
      /**
       * The xRateLimitConfig response header, of type String.
       *
       * @return the X-Rate-Limit-Config response header
       */
      public Optional<String> getXRateLimitConfig() {
        return Optional.ofNullable(xRateLimitConfig);
      }
      /**
       * The xRateLimitLimit response header, of type String.
       *
       * @return the X-Rate-Limit-Limit response header
       */
      public Optional<String> getXRateLimitLimit() {
        return Optional.ofNullable(xRateLimitLimit);
      }
      /**
       * The xRateLimitRemaining response header, of type Integer.
       *
       * @return the X-Rate-Limit-Remaining response header
       */
      public Optional<Integer> getXRateLimitRemaining() {
        return Optional.ofNullable(xRateLimitRemaining);
      }
      /**
       * The eTag response header, of type String.
       *
       * @return the ETag response header
       */
      public Optional<String> getETag() {
        return Optional.ofNullable(eTag);
      }
      /**
       * The lastModified response header, of type String.
       *
       * @return the Last-Modified response header
       */
      public Optional<String> getLastModified() {
        return Optional.ofNullable(lastModified);
      }

    /**
     * Default constructor.
     */
    public UpdateMessageResponseHeaders() {
    }

    /**
     * Assigns properties from a {@link EncodedResponse response}.
     *
     * @param paramSerializer the {@link ParamSerializer paramSerializer} to use for deserialization
     * @param response the {@link EncodedResponse response} to extract properties from
     * @return the {@link EncodedResponse}
     */
    public EncodedResponse addHeaders(final ParamSerializer paramSerializer,
            final EncodedResponse response) { 
        response.getMetadata("X-Rate-Limit-Config").ifPresent(val -> this.xRateLimitConfig = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Limit").ifPresent(val -> this.xRateLimitLimit = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Remaining").ifPresent(val -> this.xRateLimitRemaining = paramSerializer.deserialize(val, Integer.class));
        response.getMetadata("ETag").ifPresent(val -> this.eTag = paramSerializer.deserialize(val, String.class));
        response.getMetadata("Last-Modified").ifPresent(val -> this.lastModified = paramSerializer.deserialize(val, String.class));
        return response;
      }
    }

  

// -------- Start of HelloMessageClient --------

    private final ServiceClient serviceClient;
    private final ClientId clientId;
    private final TwilioMetricRegistry metricsRegistry;
    private final ClientConfiguration clientConfiguration;
    private final Optional<CircuitBreakerConfig> circuitBreakerConfig;
    private final ParamSerializer paramSerializer;

    private HelloMessageClient(final ServiceClient serviceClient, final ClientId clientId,
        final ClientConfiguration clientConfiguration,
        final Optional<CircuitBreakerConfig> circuitBreakerConfig,
        final TwilioMetricRegistry metricsRegistry,
        final ParamSerializer paramSerializer) {

        this.serviceClient = serviceClient;
        this.clientId = clientId;
        this.clientConfiguration = clientConfiguration;
        this.metricsRegistry = metricsRegistry;
        this.circuitBreakerConfig = circuitBreakerConfig;
        this.paramSerializer = paramSerializer;
    }

    @Override
    public ClientId getClientId() {
        return this.clientId;
    }

    private static void multiMapPut(final Map<String, List<Object>> map, final String key,
            final Object value) {

        map.computeIfAbsent(key, e -> new ArrayList<>());

        map.computeIfPresent(key, (k, l) -> {
            if (value instanceof Iterable) {
                ((Iterable) value).forEach(v -> l.add(v));
            } else {
                l.add(value);
            }
            return l;
        });
    }

  // -------- Start CallBuilder(s) Operations --------
    
    /**
     * Method to create a {@link CreateMessageCallBuilder}.
     * 
     * @param helloMessage assign helloMessage a {@link HelloMessage}
     * @param sid A unique message SID identifier  a {@link com.twilio.sids.SmsSid}
     * @param etag assign etag a {@link String}
     * @param responseHeaders {@link HelloMessageClient.CreateMessageResponseHeaders headers} 
     * @param requestContext the {@link com.twilio.core.request.context.RequestContext}
     * @return a {@link CreateMessageCallBuilder}
     */
    public CreateMessageCallBuilder createMessage(
        final HelloMessage helloMessage, 
        final com.twilio.sids.SmsSid sid,
        final String etag,
        final HelloMessageClient.CreateMessageResponseHeaders responseHeaders,
        
        final com.twilio.core.request.context.RequestContext requestContext) {

        // assign path parameters, if available
        final var pathMap = Map.<String, Object>of("sid", sid);

        final var uri = jakarta.ws.rs.core.UriBuilder.fromPath("/Service/Messages/{sid}")
            .buildFromMap(pathMap);

        final var metadataBuilder = DefaultMetadata.builder();
        final var metrics = CreateMessageCallBuilder.ensureMetrics(metricsRegistry, clientConfiguration.getMetricsPrefix());
        final var circuitBreaker = CreateMessageCallBuilder.ensureBreaker(circuitBreakerConfig, metrics);

        return new CreateMessageCallBuilder(serviceClient, circuitBreaker, metrics,
                UriBuilder.uriBuilder().path(uri.getPath()), metadataBuilder,
                helloMessage,
                responseHeaders, requestContext, paramSerializer)
            .etag(etag);
    }
    
    /**
     * Method to create a {@link DeleteMessageCallBuilder}.
     * 
     * @param sid A unique message SID identifier  a {@link com.twilio.sids.SmsSid}
     * @param responseHeaders {@link HelloMessageClient.DeleteMessageResponseHeaders headers} 
     * @param requestContext the {@link com.twilio.core.request.context.RequestContext}
     * @return a {@link DeleteMessageCallBuilder}
     */
    public DeleteMessageCallBuilder deleteMessage(
        final com.twilio.sids.SmsSid sid,
        final HelloMessageClient.DeleteMessageResponseHeaders responseHeaders,
        
        final com.twilio.core.request.context.RequestContext requestContext) {

        // assign path parameters, if available
        final var pathMap = Map.<String, Object>of("sid", sid);

        final var uri = jakarta.ws.rs.core.UriBuilder.fromPath("/Service/Messages/{sid}")
            .buildFromMap(pathMap);

        final var metadataBuilder = DefaultMetadata.builder();
        final var metrics = DeleteMessageCallBuilder.ensureMetrics(metricsRegistry, clientConfiguration.getMetricsPrefix());
        final var circuitBreaker = DeleteMessageCallBuilder.ensureBreaker(circuitBreakerConfig, metrics);

        return new DeleteMessageCallBuilder(serviceClient, circuitBreaker, metrics,
                UriBuilder.uriBuilder().path(uri.getPath()), metadataBuilder,
                responseHeaders, requestContext, paramSerializer);
    }
    
    /**
     * Method to create a {@link GetMessageCallBuilder}.
     * 
     * @param sid A unique message SID identifier  a {@link com.twilio.sids.SmsSid}
     * @param responseHeaders {@link HelloMessageClient.GetMessageResponseHeaders headers} 
     * @param conditional a {@link ConditionalRequest} 
     * @param requestContext the {@link com.twilio.core.request.context.RequestContext}
     * @return a {@link GetMessageCallBuilder}
     */
    public GetMessageCallBuilder getMessage(
        final com.twilio.sids.SmsSid sid,
        final HelloMessageClient.GetMessageResponseHeaders responseHeaders,
        final ConditionalRequest conditional,
        final com.twilio.core.request.context.RequestContext requestContext) {

        // assign path parameters, if available
        final var pathMap = Map.<String, Object>of("sid", sid);

        final var uri = jakarta.ws.rs.core.UriBuilder.fromPath("/Service/Messages/{sid}")
            .buildFromMap(pathMap);

        final var metadataBuilder = DefaultMetadata.builder();
        final var metrics = GetMessageCallBuilder.ensureMetrics(metricsRegistry, clientConfiguration.getMetricsPrefix());
        final var circuitBreaker = GetMessageCallBuilder.ensureBreaker(circuitBreakerConfig, metrics);

        return new GetMessageCallBuilder(serviceClient, circuitBreaker, metrics,
                UriBuilder.uriBuilder().path(uri.getPath()), metadataBuilder,
                responseHeaders, requestContext, paramSerializer)
            .conditional(conditional);
    }
    
    /**
     * Method to create a {@link ListMessagesCallBuilder}.
     * 
     * @param from A sender name  a {@link String}
     * @param to A recipient name  a {@link String}
     * @param pageSize Number of results to return at once  a {@link Integer}
     * @param pageToken Opaque token describing which page of results to return  a {@link String}
     * @param responseHeaders {@link HelloMessageClient.ListMessagesResponseHeaders headers} 
     * @param requestContext the {@link com.twilio.core.request.context.RequestContext}
     * @return a {@link ListMessagesCallBuilder}
     */
    public ListMessagesCallBuilder listMessages(
        final String from,
        final String to,
        final Integer pageSize,
        final String pageToken,
        final HelloMessageClient.ListMessagesResponseHeaders responseHeaders,
        
        final com.twilio.core.request.context.RequestContext requestContext) {

        // assign path parameters, if available
        final var pathMap = Map.<String, Object>of();

        final var uri = jakarta.ws.rs.core.UriBuilder.fromPath("/Service/Messages")
            .buildFromMap(pathMap);

        final var metadataBuilder = DefaultMetadata.builder();
        final var metrics = ListMessagesCallBuilder.ensureMetrics(metricsRegistry, clientConfiguration.getMetricsPrefix());
        final var circuitBreaker = ListMessagesCallBuilder.ensureBreaker(circuitBreakerConfig, metrics);

        return new ListMessagesCallBuilder(serviceClient, circuitBreaker, metrics,
                UriBuilder.uriBuilder().path(uri.getPath()), metadataBuilder,
                responseHeaders, requestContext, paramSerializer)
            .from(from)
            .to(to)
            .pageSize(pageSize)
            .pageToken(pageToken);
    }
    
    /**
     * Method to create a {@link UpdateMessageCallBuilder}.
     * 
     * @param sid A unique message SID identifier  a {@link com.twilio.sids.SmsSid}
     * @param from Sender address  a {@link String}
     * @param to Recipient address  a {@link String}
     * @param message Message body  a {@link String}
     * @param responseHeaders {@link HelloMessageClient.UpdateMessageResponseHeaders headers} 
     * @param conditional a {@link ConditionalRequest} 
     * @param requestContext the {@link com.twilio.core.request.context.RequestContext}
     * @return a {@link UpdateMessageCallBuilder}
     */
    public UpdateMessageCallBuilder updateMessage(
        final com.twilio.sids.SmsSid sid,
        final String from,
        final String to,
        final String message,
        final HelloMessageClient.UpdateMessageResponseHeaders responseHeaders,
        final ConditionalRequest conditional,
        final com.twilio.core.request.context.RequestContext requestContext) {

        // assign path parameters, if available
        final var pathMap = Map.<String, Object>of("sid", sid);

        final var uri = jakarta.ws.rs.core.UriBuilder.fromPath("/Service/Messages/{sid}")
            .buildFromMap(pathMap);

        final var metadataBuilder = DefaultMetadata.builder();
        final var metrics = UpdateMessageCallBuilder.ensureMetrics(metricsRegistry, clientConfiguration.getMetricsPrefix());
        final var circuitBreaker = UpdateMessageCallBuilder.ensureBreaker(circuitBreakerConfig, metrics);

        return new UpdateMessageCallBuilder(serviceClient, circuitBreaker, metrics,
                UriBuilder.uriBuilder().path(uri.getPath()), metadataBuilder,
                responseHeaders, requestContext, paramSerializer)
            .from(from)
            .to(to)
            .message(message)
            .conditional(conditional);
    }
    
}