/*
 * FlexMaestro Service
 * This is a basic FlexMaestro service, showcasing many features of a standard Twilio Service
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: your-team-name@twilio.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.twilio.flexmaestro.client.api.admin;

import com.twilio.core.jersey3.auth.annotations.HostAuth;
import com.twilio.flexmaestro.client.definitions.HelloMessageList;
import com.twilio.core.security.contexts.RemoteHostContext;
import com.twilio.rest.TwilioServiceErrorResponse;
import com.twilio.concurrency.limit.annotations.AIMDConcurrencyLimited;
import io.vavr.control.Either;
import jakarta.ws.rs.container.AsyncResponse;
import com.twilio.core.request.context.RequestContext;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.twilio.platform.metrics.noop.NoopTwilioMetricRegistry;
import com.twilio.core.retry.policy.DefaultRetryPolicy;
import com.twilio.http.asyncv2.AsyncHttpClientBuilder;
import com.twilio.coreutil.resiliency.circuitbreaker.CircuitBreaker;
import com.twilio.coreutil.resiliency.circuitbreaker.NoopCircuitBreaker;
import com.twilio.coreutil.resiliency.circuitbreaker.config.CircuitBreakerConfig;
import com.twilio.coreutil.configuration.client.ClientConfiguration;
import com.twilio.core.util.transcoding.Transcoder;
import com.twilio.core.util.transcoding.TranscodingException;


import jakarta.validation.constraints.*;
import com.twilio.flexmaestro.client.api.Endpoint;
import com.twilio.flexmaestro.client.ClientRequestType;
import com.twilio.flexmaestro.client.NoopResponseHandler;
import com.twilio.flexmaestro.client.DefaultRequestHandlerProvider;
import com.twilio.flexmaestro.client.RequestHandlerProvider;
import com.twilio.flexmaestro.client.ParamSerializer;
import com.twilio.core.client.ahc.AbstractAhcServiceClientBuilder;
import com.twilio.coreutil.resiliency.circuitbreaker.CircuitBreaker;
import com.twilio.coreutil.resiliency.circuitbreaker.config.CircuitBreakerConfig;
import com.twilio.core.client.base.ServiceClient;
import com.twilio.core.client.base.call.CallBuilder;
import com.twilio.core.client.base.exceptions.ServiceResponseException;
import com.twilio.core.client.base.handlers.DefaultRequestHandler;
import com.twilio.core.client.base.id.ClientId;
import com.twilio.core.client.base.id.DefaultClientId;
import com.twilio.core.client.base.id.IdentifiableClient;
import com.twilio.core.client.base.metadata.DefaultMetadata;
import com.twilio.core.client.base.response.EncodedResponse;
import com.twilio.core.jackson.JacksonTranscoder;
import com.twilio.core.routing.URIServiceRouteResolver;
import com.twilio.core.util.UriBuilder;
import com.twilio.core.util.concurrent.Futures;
import com.twilio.core.util.transcoding.UrlencodedFormDataTranscoder;
import com.twilio.core.domain.ServiceError;
import com.twilio.core.domain.ErrorCode;
import com.twilio.rest.TwilioServiceErrorException;

import com.twilio.coreutil.ThreadFactoryImpl;
import com.twilio.json.JsonUtil;
import com.twilio.platform.metrics.TwilioMetricRegistry;
import com.twilio.platform.metrics.TwilioMeter;
import com.twilio.platform.metrics.TwilioTimer;

import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.nio.charset.StandardCharsets;
import java.io.IOException;

import com.twilio.coreutil.logging.MDCCompletableFuture;
import static com.twilio.coreutil.Exceptions.findNestedException;
import static com.twilio.coreutil.Futures.composeExceptionally;
import static java.util.Objects.requireNonNullElse;

import java.util.Objects;
import static java.util.Objects.equals;
import static java.util.Objects.hash;
import static java.util.Objects.nonNull;
import static java.util.Objects.requireNonNull;
import static java.util.Objects.isNull;
import static java.util.Objects.requireNonNullElse;

import com.twilio.core.request.context.RequestContext;
import com.twilio.core.security.principals.AuthenticatedAccount;
import com.twilio.core.security.principals.AuthenticatedUser;
import com.twilio.sids.HostSid;

import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.Optional;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.Executors;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;

/**
 * A client providing access to the following operations.
 *
 * <ul>
 * 
 * <li>readMessages</li>
 * </ul>
 */

@jakarta.annotation.Generated(value = "com.twilio.codegen.TwilioGenerator", date = "2024-04-01T15:05:48.196693+05:30[Asia/Kolkata]")
public class AdminClient implements IdentifiableClient {

    /**
   * Builder that produces AdminClient instances.
   */
  public static class Builder extends AbstractAhcServiceClientBuilder<Builder> {
    private static final URI DEFAULT_BASE_URL = URI.create("http://localhost:9876/v1");
    private static final String DEFAULT_CLIENT_NAME = "flex-maestro-integration-tests-AdminClient";
    private static final String CLIENT_VERSION = "1.0.0";
    private static final Set<Integer> shouldNotRetryOnStatusCode = Set.of(200, 201, 202, 204, 302, 400, 401, 402, 403, 404, 409, 410, 415, 422);

    private final ClientConfiguration clientConfiguration;
    private String clientName = DEFAULT_CLIENT_NAME;
    private String clientVersion = CLIENT_VERSION;
    private Optional<HostSid> hostSid = Optional.empty();
    private Optional<CircuitBreakerConfig> circuitBreakerConfig = Optional.empty();
    private TwilioMetricRegistry metricsRegistry;
    private ParamSerializer paramSerializer;

    /**
     * Create a new Builder using the specified <code>clientConfiguration</code>.
     *
     * @param clientConfiguration a {@link ClientConfiguration}
     */
    public Builder(final ClientConfiguration clientConfiguration) {
      tracing(true);
      this.clientConfiguration = clientConfiguration;
      if (clientConfiguration.getBaseUri() != null) {
        routeResolver(new URIServiceRouteResolver(clientConfiguration.getBaseUri()));
      }
      clientName = clientConfiguration.getClientName();
      clientVersion = clientConfiguration.getClientVersion();
      hostSid = Optional.ofNullable(clientConfiguration.getHostSid());
      circuitBreakerConfig  = Optional.ofNullable(clientConfiguration.getCircuitBreakerProperties());

      if (clientConfiguration.getConnectionProperties() != null) {
        // threadName is metricsPrefix or clientName or DEFAULT_CLIENT_NAME adding '-' at the end
        final var threadName = Optional.ofNullable(clientConfiguration.getMetricsPrefix())
            .orElse(Optional.ofNullable(clientName).orElse(DEFAULT_CLIENT_NAME)) + "-";
        client(new AsyncHttpClientBuilder(new ThreadFactoryImpl(threadName))
            .using(clientConfiguration.getConnectionProperties()).build());
      }

      retry(DefaultRetryPolicy.builder().retryIf(t -> {
          final var serviceResponseException = findExceptionByClass(t, ServiceResponseException.class);
          if (serviceResponseException != null) {
              return !shouldNotRetryOnStatusCode.contains(serviceResponseException.getStatusCode());
          }
          return false;
        }).build());
    }

    /**
     * Assign the client's {@link java.net.URI baseUrl}.
     *
     * @param baseUrl the {@link java.net.URI used as the common url}
     * @return the {@link Builder self }
     */
    public Builder baseUrl(final java.net.URI baseUrl) {
      routeResolver(new URIServiceRouteResolver(requireNonNull(baseUrl, "baseUrl is required")));
      return this;
    }

    /**
     * Assign the client's {@link String clientName}.
     *
     * @param clientName the {@link String name of the client}
     * @return the {@link Builder self}
     */
    public Builder clientName(final String clientName) {
      this.clientName = requireNonNull(clientName, "clientName is required");
      return this;
    }

    /**
     * Assign the client's {@link CircuitBreakerConfig circuitBreakerConfig}.
     *
     * @param circuitBreakerConfig the {@link CircuitBreakerConfig}
     * @return the {@link Builder self}
     */
    public Builder circuitBreakerConfig(final CircuitBreakerConfig circuitBreakerConfig) {
      this.circuitBreakerConfig = Optional.ofNullable(circuitBreakerConfig);
      return this;
    }

    /**
     * Assign the client's {@link TwilioMetricRegistry metricRegistry}.
     *
     * @param metricRegistry {@link TwilioMetricRegistry metrics registry}
     * @return the {@link Builder self}
     */
    public Builder metricsRegistry(final TwilioMetricRegistry metricRegistry) {
      this.metricsRegistry = metricRegistry;
      return this;
    }

    /**
     * Assign the client's {@link HostSid hostSid}.
     *
     * @param hostSid the {@link HostSid host SID}
     * @return the {@link Builder self}
     */
    public Builder hostSid(final HostSid hostSid) {
      this.hostSid = Optional.ofNullable(hostSid);
      return this;
    }

    /**
     * Assign the client's {@link ObjectMapper objectMapper}.
     *
     * @param objectMapper the {@link ObjectMapper}
     * @return the {@link Builder self}
     */
    public Builder objectMapper(final ObjectMapper objectMapper) {
      transcoder(new JacksonTranscoder(
        JsonUtil.configureJsonMapper(requireNonNull(objectMapper, "objectMapper is required"))));
        paramSerializer = ParamSerializer.getInstance(objectMapper);
      return this;
    }

    /**
     * Create a new {@link AdminClient} instance.
     *
     * @return a new {@link AdminClient}
     */
    public AdminClient build() {
      if (isNull(this.routeResolver)) {
        routeResolver(new URIServiceRouteResolver(DEFAULT_BASE_URL));
      }

      if (isNull(this.clientId)) {
        clientId(new DefaultClientId(clientName, clientVersion, hostSid.orElse(null)));
      }

      if (isNull(this.metricsRegistry)) {
        metricsRegistry(new NoopTwilioMetricRegistry());
      }

      if (isNull(this.transcoder)) {
        transcoder(new JacksonTranscoder(JsonUtil.configureJsonMapper()));
      }

      if (isNull(this.paramSerializer)) {
         paramSerializer = ParamSerializer.getInstance(JsonUtil.configureJsonMapper());
      }

      return new AdminClient(buildClient(),
        clientId,
        clientConfiguration,
        circuitBreakerConfig,
        metricsRegistry,
        paramSerializer);
    }

    private <T extends Throwable> T findExceptionByClass(final Throwable t, final Class<T> exceptionClass) {
      Throwable current = t;

      while (current != null) {
        if (exceptionClass.isInstance(current)) {
            return (T) current;
        }

        current = current.getCause();
      }

      return null;
    }
  }

  
  

    // -------- Start ReadMessagesCallBuilder --------

  /**
   * A type that is used to call the ReadMessages operation.
   */
    public final static class ReadMessagesCallBuilder implements Endpoint {
        private static final String ENDPOINT_NAME = "read_messages";
        private static final String ENDPOINT_PROJECT_NAME = "flex-maestro-integration-tests";
        private static final RequestHandlerProvider REQUEST_HANDLER_PROVIDER = new DefaultRequestHandlerProvider();
        private static final Set<String> REQUIRED_QUERY_PARAMS = Set.of();
        private static final Set<String> REQUIRED_HEADER_PARAMS = Set.of();

        private static CircuitBreaker CIRCUIT_BREAKER;
        private static Metrics METRICS;

        private final ServiceClient serviceClient;
        private final UriBuilder uriBuilder;
        private final CircuitBreaker circuitBreaker;
        private final Metrics metrics;
        private final DefaultMetadata.Builder metadataBuilder;
        private final ParamSerializer paramSerializer;
        private final AdminClient.ReadMessagesResponseHeaders responseHeaders;
        private final Set<String> assignedQueryParams = new HashSet<>();
        private final Set<String> assignedHeaderParams = new HashSet<>();

    
        private final com.twilio.core.request.context.RequestContext requestContext;

        private ReadMessagesCallBuilder(
            final ServiceClient serviceClient,
            final CircuitBreaker circuitBreaker,
            final Metrics metrics,
            final UriBuilder uriBuilder,
            final DefaultMetadata.Builder metadataBuilder,
            
            final AdminClient.ReadMessagesResponseHeaders responseHeaders,
            final com.twilio.core.request.context.RequestContext requestContext,
            final ParamSerializer paramSerializer) {

                this.serviceClient = serviceClient;
                this.uriBuilder = uriBuilder;
                this.metadataBuilder = metadataBuilder;
                this.requestContext = requestContext;
                this.circuitBreaker = circuitBreaker;
                this.metrics = metrics;
                this.paramSerializer = paramSerializer;
                this.responseHeaders = responseHeaders;

                requestContext.streamMetadata()
                    .filter(entry -> entry.getKey().toLowerCase(Locale.US).startsWith("t-")
                        || entry.getKey().toLowerCase(Locale.US).startsWith("i-twilio-"))
                    .forEach(entry -> this.metadataBuilder.add(entry.getKey(), entry.getValue()));
        }
    
        /**
     * Set &quot;pageSize&quot; parameter .
     *
     * @param pageSize Number of results to return at once  a {@link Integer}
     * @return the {@link ReadMessagesCallBuilder}
     */
    public ReadMessagesCallBuilder pageSize(final Integer pageSize) {
      // ensure value isn't null, if null then do not add the parameter
      if (nonNull(pageSize)) { 
        this.uriBuilder.addQueryParam("PageSize", paramSerializer.serialize(pageSize));
        assignedQueryParams.add("pageSize");
      } else { 
        assignedQueryParams.remove("pageSize");
      }
      return this;
    }
                
        /**
     * Set &quot;pageToken&quot; parameter .
     *
     * @param pageToken Opaque token describing which page of results to return  a {@link String}
     * @return the {@link ReadMessagesCallBuilder}
     */
    public ReadMessagesCallBuilder pageToken(final String pageToken) {
      // ensure value isn't null, if null then do not add the parameter
      if (nonNull(pageToken)) { 
        this.uriBuilder.addQueryParam("PageToken", paramSerializer.serialize(pageToken));
        assignedQueryParams.add("pageToken");
      } else { 
        assignedQueryParams.remove("pageToken");
      }
      return this;
    }
                
    
    /**
     * Set the header parameter with the <code>name</code> to the specified <code>value</code>.
     *
     * @param name the {@link String name} of the header field
     * @param value the {@link String value} to set or remove if value is an empty string
     * @return the {@link ReadMessagesCallBuilder}
     */
    @Override
    public ReadMessagesCallBuilder header(final String name, final Object value) {
        if (value instanceof String && ((String) value).isEmpty()) {
            this.metadataBuilder.remove(name);
        } else {
            this.metadataBuilder.add(name, paramSerializer.serialize(value));
        }
        return this;
    }

    /**
     * Calls ReadMessages.
     * 
     * @return the {@link CompletionStage} of an {@link Either} with {@link TwilioServiceErrorResponse left} and {@link HelloMessageList right}
     */
    public CompletionStage<HelloMessageList> call() { 

        checkParameters();
        metadataBuilder.add("Content-Type", "application/json; charset=utf-8");
        final CallBuilder<Void, EncodedResponse> builder = new CallBuilder<>("GET", uriBuilder.build(),
                "read_messages", null,
                metadataBuilder.build(), serviceClient, new DefaultRequestHandler(),
                NoopResponseHandler.INSTANCE);

        // Add requestSid from request context
        builder.requestSid(this.requestContext.getRequestSid());

        // If principal is available then add it to the request
        requestContext.getPrincipal().ifPresent(principal -> {
            if (principal instanceof AuthenticatedAccount) {
                builder.principal(((AuthenticatedAccount) principal).getSid());
            } else if (principal instanceof AuthenticatedUser) {
                builder.principal(((AuthenticatedUser) principal).getSid());
            }
        });

        try (final var ignore = metrics.getRequestTimer().time()) {
            metrics.markRequest();

            return handleError(withBreaker(builder))
                .thenCompose(
                      r -> create(r, serviceClient.getTranscoder(), responseHeaders)
                .thenApply(re -> {
                      metrics.markRequestSucceeded();
                      return re;
                }))                .whenComplete((r, t) -> {
                    if (t != null) {
                        metrics.markRequestFailed();
                }
            });
        }
    }

    @Override
    public String getOperationName() {
        return ENDPOINT_NAME;
    }

    @Override
    public String getOperationProject() {
      return ENDPOINT_PROJECT_NAME;
    }

    /**
     * Check that all required body|form, header and query parameters has been set.
     **/
    private void checkParameters() {
        
    }

    private CompletionStage<EncodedResponse> handleError(
        final CompletionStage<? extends EncodedResponse> completionStage) {

        final var completableFuture = new MDCCompletableFuture<EncodedResponse>();
        completionStage.whenComplete((er, t) -> {
            if (t == null) {
                completableFuture.complete(er);
                return;
            }
            findNestedException(t, ServiceResponseException.class)
                .ifPresentOrElse(sre -> {
                    if (!isTextPlain(sre)) {
                        // map error service response exception to a non-exceptional future, so we can map it
                        completableFuture.complete(sre.getResponse());
                    } else {
                        completableFuture.completeExceptionally(handleTextPlainError(sre));
                    }
                },
                () -> {
                    // non-serviceResponseException
                    completableFuture.completeExceptionally(t);
                });
        });
        return completableFuture;
    }

    private ServiceResponseException handleTextPlainError(final ServiceResponseException sre) {
        // Add text/plain body to the ServiceError
        return sre.getResponse().getPayloadSource()
            .map(payloadSource -> {
                String errorMessage;
                try {
                    errorMessage = new String(payloadSource.createStream().readAllBytes(), StandardCharsets.UTF_8);
                } catch (final IOException e) {
                    errorMessage = "Unable to retrieve body of text/plain response";
                }

                final var serviceErrorBuilder = ServiceError.builder().message(errorMessage);
                if (isEnvoyCircuitBreaking(sre)) {
                    serviceErrorBuilder.code(ErrorCode.DOWNSTREAM_OVERLOADED);
                }
                return new ServiceResponseException(sre.getResponse(), serviceErrorBuilder.build());
          })
          .orElse(sre);
    }

    private boolean isEnvoyCircuitBreaking(final ServiceResponseException serviceResponseException) {
        return serviceResponseException.getResponse().getMetadata("x-envoy-overloaded")
            .map(Boolean::parseBoolean)
            .orElse(false);
    }

    private final boolean isTextPlain(final ServiceResponseException serviceResponseException) {
        return serviceResponseException.getResponse().getMetadata("content-type")
            .filter(s -> s.startsWith("text/plain")).isPresent();
    }

    private CompletionStage<HelloMessageList> create(final EncodedResponse response, final Transcoder transcoder,
    final AdminClient.ReadMessagesResponseHeaders responseHeaders) {
    
        // Populate response headers
        responseHeaders.addHeaders(paramSerializer, response);

        try {
            switch (response.getStatusCode()) {
            
            case 200: { 
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<HelloMessageList>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageList"));
                return MDCCompletableFuture.completedFuture(value);
            }
            case 401: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageList"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 403: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageList"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 500: { 
                metrics.mark500Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageList"));
                throw new TwilioServiceErrorException(value, response);
            }
            case 429: { 
                metrics.mark400Response();
                final var value = response
                    .getPayloadSource()
                    .map(source -> paramSerializer.deserialize(source.createStream(), new TypeReference<com.twilio.rest.TwilioServiceErrorResponse>(){}))
                    .orElseThrow(() -> new TranscodingException(
                        "No payload source available to unmarshal to type HelloMessageList"));
                throw new TwilioServiceErrorException(value, response);
            }

            default:
                return MDCCompletableFuture.failedFuture(new ServiceResponseException(response));
            }
        } catch (final Exception e) {
            return MDCCompletableFuture.failedFuture(e);
        }
    }

    private CompletionStage<? extends EncodedResponse> withBreaker(final CallBuilder<Void, EncodedResponse> builder) {
        return circuitBreaker.decorate(() -> builder.call())
            .withFailurePredicate(encodedResponse -> {
                return encodedResponse.getStatusCode() >= 500;
            }).withIgnoreExceptionPredicate(throwable -> {
                  if (throwable instanceof ServiceResponseException) {
                        final var exception = (ServiceResponseException) throwable.getCause();
                        return exception.getResponse().getStatusCode() < 500;
                  }
                  return false;
        }).execute();
    }

    private static CircuitBreaker ensureBreaker(final Optional<CircuitBreakerConfig> circuitBreakerConfig,
        final Metrics metrics) {

        if (isNull(CIRCUIT_BREAKER)) {
            CIRCUIT_BREAKER = circuitBreakerConfig
                .map(config -> CircuitBreaker.builder()
                    .withCircuitBreakerConfig(config)
                    .withOnClose(metrics::markCircuitBreakerClosed)
                    .withOnHalfOpen(metrics::markCircuitBreakerHalfOpen)
                    .withOnOpen(metrics::markCircuitBreakerOpen)
                    .withName(ENDPOINT_NAME)
                    .build())
                .orElse(new NoopCircuitBreaker());
        }
        return CIRCUIT_BREAKER;
    }

    private static Metrics ensureMetrics(final TwilioMetricRegistry metricsRegistry, final String metricsPrefix) {
      if (isNull(METRICS)) {
            METRICS = new Metrics(metricsRegistry, metricsPrefix);
      }
      return METRICS;
    }

      /**
     * Metrics holder for ReadMessagesCallBuilder.
     */
    static class Metrics {
      private final TwilioMeter request400s;
      private final TwilioMeter request500s;
      private final TwilioMeter requestFailed;
      private final TwilioMeter requestMeter;
      private final TwilioMeter requestSucceeded;
      private final TwilioTimer requestTimer;

      private final TwilioMeter cbClosed;
      private final TwilioMeter cbHalfOpen;
      private final TwilioMeter cbOpen;

      Metrics(final TwilioMetricRegistry metricRegistry, final String metricsPrefix) {
        final String prefix = requireNonNullElse(metricsPrefix, ENDPOINT_PROJECT_NAME);
        requestMeter = metricRegistry.meter(String.format("%s_%s_client_requests", prefix, ENDPOINT_NAME));
        requestFailed = metricRegistry.meter(String.format("%s_%s_client_requests_failed", prefix, ENDPOINT_NAME));
        requestSucceeded = metricRegistry.meter(String.format("%s_%s_client_requests_succeeded", prefix, ENDPOINT_NAME));
        requestTimer = metricRegistry.timer(String.format("%s_%s_client_requests_timer", prefix, ENDPOINT_NAME));
        request400s = metricRegistry.meter(String.format("%s_%s_client_requests_4XXs", prefix, ENDPOINT_NAME));
        request500s = metricRegistry.meter(String.format("%s_%s_client_requests_5XXs", prefix, ENDPOINT_NAME));

        // circuit breaker metrics
        cbClosed = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_closed", prefix, ENDPOINT_NAME));
        cbHalfOpen = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_half_open", prefix, ENDPOINT_NAME));
        cbOpen = metricRegistry.meter(String.format("%s_%s_client_circuit_breaker_open", prefix, ENDPOINT_NAME));
      }

      /**
       * Marks a 4xx response.
       */
      void mark400Response() {
        request400s.mark();
      }

      /**
       * Marks a 5xx response.
       */
      void mark500Response() {
        request500s.mark();
      }

      /**
       * Marks a failed request.
       */
      void markRequestFailed() {
        requestFailed.mark();
      }

      /**
       * Marks an attempted request.
       */
      void markRequest() {
        requestMeter.mark();
      }

      /**
       * Marks an attempted request.
       */
      void markRequestSucceeded() {
        requestSucceeded.mark();
      }

      /**
       * Get the request timer.
       *
       * @return the {@link TwilioTimer}
       */
      TwilioTimer getRequestTimer() {
        return requestTimer;
      }

      /**
       * Mark the closing of the circuit breaker.
       */
      void markCircuitBreakerClosed() {
        cbClosed.mark();
      }

      /**
       * Mark the half opening of the circuit breaker.
       */
      void markCircuitBreakerHalfOpen() {
        cbHalfOpen.mark();
      }

      /**
       * Mark the opening of the circuit breaker.
       */
      void markCircuitBreakerOpen() {
        cbOpen.mark();
      }
    }

  }
  // -------- End of ReadMessagesCallBuilder --------
    /**
   * A type to provide strongly typed header variables from a {@link EncodedResponse response}.
   */
  public static final class ReadMessagesResponseHeaders {
    
    /**
     * The etag header variable, of type String.
     */
    public String etag;
    /**
     * The xRateLimitConfig header variable, of type String.
     */
    public String xRateLimitConfig;
    /**
     * The xRateLimitLimit header variable, of type String.
     */
    public String xRateLimitLimit;
    /**
     * The xRateLimitRemaining header variable, of type Integer.
     */
    public Integer xRateLimitRemaining;

    
      /**
       * The etag response header, of type String.
       *
       * @return the etag response header
       */
      public Optional<String> getEtag() {
        return Optional.ofNullable(etag);
      }
      /**
       * The xRateLimitConfig response header, of type String.
       *
       * @return the X-Rate-Limit-Config response header
       */
      public Optional<String> getXRateLimitConfig() {
        return Optional.ofNullable(xRateLimitConfig);
      }
      /**
       * The xRateLimitLimit response header, of type String.
       *
       * @return the X-Rate-Limit-Limit response header
       */
      public Optional<String> getXRateLimitLimit() {
        return Optional.ofNullable(xRateLimitLimit);
      }
      /**
       * The xRateLimitRemaining response header, of type Integer.
       *
       * @return the X-Rate-Limit-Remaining response header
       */
      public Optional<Integer> getXRateLimitRemaining() {
        return Optional.ofNullable(xRateLimitRemaining);
      }

    /**
     * Default constructor.
     */
    public ReadMessagesResponseHeaders() {
    }

    /**
     * Assigns properties from a {@link EncodedResponse response}.
     *
     * @param paramSerializer the {@link ParamSerializer paramSerializer} to use for deserialization
     * @param response the {@link EncodedResponse response} to extract properties from
     * @return the {@link EncodedResponse}
     */
    public EncodedResponse addHeaders(final ParamSerializer paramSerializer,
            final EncodedResponse response) { 
        response.getMetadata("etag").ifPresent(val -> this.etag = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Config").ifPresent(val -> this.xRateLimitConfig = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Limit").ifPresent(val -> this.xRateLimitLimit = paramSerializer.deserialize(val, String.class));
        response.getMetadata("X-Rate-Limit-Remaining").ifPresent(val -> this.xRateLimitRemaining = paramSerializer.deserialize(val, Integer.class));
        return response;
      }
    }

  

// -------- Start of AdminClient --------

    private final ServiceClient serviceClient;
    private final ClientId clientId;
    private final TwilioMetricRegistry metricsRegistry;
    private final ClientConfiguration clientConfiguration;
    private final Optional<CircuitBreakerConfig> circuitBreakerConfig;
    private final ParamSerializer paramSerializer;

    private AdminClient(final ServiceClient serviceClient, final ClientId clientId,
        final ClientConfiguration clientConfiguration,
        final Optional<CircuitBreakerConfig> circuitBreakerConfig,
        final TwilioMetricRegistry metricsRegistry,
        final ParamSerializer paramSerializer) {

        this.serviceClient = serviceClient;
        this.clientId = clientId;
        this.clientConfiguration = clientConfiguration;
        this.metricsRegistry = metricsRegistry;
        this.circuitBreakerConfig = circuitBreakerConfig;
        this.paramSerializer = paramSerializer;
    }

    @Override
    public ClientId getClientId() {
        return this.clientId;
    }

    private static void multiMapPut(final Map<String, List<Object>> map, final String key,
            final Object value) {

        map.computeIfAbsent(key, e -> new ArrayList<>());

        map.computeIfPresent(key, (k, l) -> {
            if (value instanceof Iterable) {
                ((Iterable) value).forEach(v -> l.add(v));
            } else {
                l.add(value);
            }
            return l;
        });
    }

  // -------- Start CallBuilder(s) Operations --------
    
    /**
     * Method to create a {@link ReadMessagesCallBuilder}.
     * 
     * @param pageSize Number of results to return at once  a {@link Integer}
     * @param pageToken Opaque token describing which page of results to return  a {@link String}
     * @param responseHeaders {@link AdminClient.ReadMessagesResponseHeaders headers} 
     * @param requestContext the {@link com.twilio.core.request.context.RequestContext}
     * @return a {@link ReadMessagesCallBuilder}
     */
    public ReadMessagesCallBuilder readMessages(
        final Integer pageSize,
        final String pageToken,
        final AdminClient.ReadMessagesResponseHeaders responseHeaders,
        
        final com.twilio.core.request.context.RequestContext requestContext) {

        // assign path parameters, if available
        final var pathMap = Map.<String, Object>of();

        final var uri = jakarta.ws.rs.core.UriBuilder.fromPath("/Admin/ReadMessages")
            .buildFromMap(pathMap);

        final var metadataBuilder = DefaultMetadata.builder();
        final var metrics = ReadMessagesCallBuilder.ensureMetrics(metricsRegistry, clientConfiguration.getMetricsPrefix());
        final var circuitBreaker = ReadMessagesCallBuilder.ensureBreaker(circuitBreakerConfig, metrics);

        return new ReadMessagesCallBuilder(serviceClient, circuitBreaker, metrics,
                UriBuilder.uriBuilder().path(uri.getPath()), metadataBuilder,
                responseHeaders, requestContext, paramSerializer)
            .pageSize(pageSize)
            .pageToken(pageToken);
    }
    
}