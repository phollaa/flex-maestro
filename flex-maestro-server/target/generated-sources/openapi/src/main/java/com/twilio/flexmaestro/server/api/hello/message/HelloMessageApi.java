/*
 * FlexMaestro Service
 * This is a basic FlexMaestro service, showcasing many features of a standard Twilio Service
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: your-team-name@twilio.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.twilio.flexmaestro.server.api.hello.message;

import com.twilio.core.jersey3.auth.annotations.ApiAuth;
import com.twilio.core.security.contexts.ApiAuthContext;
import com.twilio.flexmaestro.server.definitions.HelloMessage;
import com.twilio.flexmaestro.server.definitions.HelloMessageContainer;
import com.twilio.flexmaestro.server.definitions.HelloMessageList;
import com.twilio.rest.TwilioServiceErrorResponse;
import com.twilio.concurrency.limit.annotations.AIMDConcurrencyLimited;
import io.vavr.control.Either;
import com.twilio.sids.SmsSid;
import jakarta.ws.rs.container.AsyncResponse;
import com.twilio.core.request.context.RequestContext;

import com.twilio.flexmaestro.server.api.Endpoint;

import com.twilio.core.security.contexts.RemoteHostContext;
import com.twilio.core.request.context.RequestContext;



import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.ResponseBuilder;

import java.util.Map;
import java.util.Objects;
import java.util.List;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.CompletableFuture;

import static java.util.Objects.nonNull;

import jakarta.validation.constraints.*;

import java.util.Optional;
import org.jvnet.hk2.annotations.Contract;

/**
* HelloMessageApi handler code.
*/

@jakarta.annotation.Generated(value = "com.twilio.codegen.TwilioGenerator", date = "2024-04-01T17:46:14.982174+05:30[Asia/Kolkata]")
@Contract
public interface HelloMessageApi {
  /**
   * Get the number of milliseconds to allow a request to process.
   *
   * @param operation the operation being performed
   *
   * @return number of milliseconds to process requests
   */
  default long getTimeoutMs(final String operation) {
    return 5000L;
  }
  /**
    * POST /{sid} : Create a new message
    * <ol>
    *    <li>Message created (status code 201)</li>
    *    <li>Unauthorized (status code 401)</li>
    *    <li>Forbidden (status code 403)</li>
    *    <li>Invalid HelloMessage (status code 422)</li>
    *    <li>Internal server error (status code 500)</li>
    *    <li>Rate Limit Exceeded (status code 429)</li>
    *  </ol>
    * 
    * @param sid A unique message SID identifier  a {@link com.twilio.sids.SmsSid}
    * @param etag assign etag a {@link String}
    * @param helloMessage assign helloMessage a {@link HelloMessage}
    * @param apiAuthContext the authentication context  a {@link ApiAuthContext}
    * @param requestContext the request context  a {@link com.twilio.core.request.context.RequestContext}
    * @param responseHeaders a CreateMessageResponseHeaders container to store response headers
    *
    * @return a {@link CompletionStage} of {@link Either} where left is a {@link TwilioServiceErrorResponse} and right is a {@link HelloMessageContainer } possible responses
    */
    default CompletionStage<Either<TwilioServiceErrorResponse, HelloMessageContainer>> createMessage(
        final com.twilio.sids.SmsSid sid,
        final String etag,
        final HelloMessage helloMessage,
        final ApiAuthContext apiAuthContext, 
        final com.twilio.core.request.context.RequestContext requestContext,
        final HelloMessageApi.CreateMessageResponseHeaders responseHeaders) {
        // TODO: Implement method
        return CompletableFuture.completedStage(Either.left(new TwilioServiceErrorResponse.Builder().withMessage("Method not implemented").withCode(501).withHttpStatusCode(501).build()));
    }
        
    /**
     * CreateMessageResponseHeaders is intended as a strongly typed container for
     * all the response headers sent by the downstream.
     */
    public static final class CreateMessageResponseHeaders {
    
    /**
     * The etag header variable, of type String.
     */
    public String etag;
    /**
     * The xRateLimitConfig header variable, of type String.
     */
    public String xRateLimitConfig;
    /**
     * The xRateLimitLimit header variable, of type String.
     */
    public String xRateLimitLimit;
    /**
     * The xRateLimitRemaining header variable, of type Integer.
     */
    public Integer xRateLimitRemaining;

    
      /**
       * The etag response header, of type String.
       *
       * @return the etag response header
       */
      public Optional<String> getEtag() { 
        return Optional.ofNullable(etag);
      }

      /**
       * Set the etag response header.
       *
       * @param etag the etag response header
       */
      public void setEtag(final String etag) {
          this.etag = etag;
      }

      /**
       * The xRateLimitConfig response header, of type String.
       *
       * @return the X-Rate-Limit-Config response header
       */
      public Optional<String> getXRateLimitConfig() { 
        return Optional.ofNullable(xRateLimitConfig);
      }

      /**
       * Set the xRateLimitConfig response header.
       *
       * @param xRateLimitConfig the xRateLimitConfig response header
       */
      public void setXRateLimitConfig(final String xRateLimitConfig) {
          this.xRateLimitConfig = xRateLimitConfig;
      }

      /**
       * The xRateLimitLimit response header, of type String.
       *
       * @return the X-Rate-Limit-Limit response header
       */
      public Optional<String> getXRateLimitLimit() { 
        return Optional.ofNullable(xRateLimitLimit);
      }

      /**
       * Set the xRateLimitLimit response header.
       *
       * @param xRateLimitLimit the xRateLimitLimit response header
       */
      public void setXRateLimitLimit(final String xRateLimitLimit) {
          this.xRateLimitLimit = xRateLimitLimit;
      }

      /**
       * The xRateLimitRemaining response header, of type Integer.
       *
       * @return the X-Rate-Limit-Remaining response header
       */
      public Optional<Integer> getXRateLimitRemaining() { 
        return Optional.ofNullable(xRateLimitRemaining);
      }

      /**
       * Set the xRateLimitRemaining response header.
       *
       * @param xRateLimitRemaining the xRateLimitRemaining response header
       */
      public void setXRateLimitRemaining(final Integer xRateLimitRemaining) {
          this.xRateLimitRemaining = xRateLimitRemaining;
      }

        /**
         * Default constructor for CreateMessageResponseHeaders().
         */
        public CreateMessageResponseHeaders() {
        }

        /**
         * Using the specified <code>builder</code> assign all non-empty
         * header properties.
         *
         * @param builder a {@link ResponseBuilder} add header variables to
         *
         * @return the {@link ResponseBuilder}
         */
        public ResponseBuilder addHeaders(@NotNull final ResponseBuilder builder) { 
           getEtag().ifPresent(val -> builder.header("etag", val));
           getXRateLimitConfig().ifPresent(val -> builder.header("X-Rate-Limit-Config", val));
           getXRateLimitLimit().ifPresent(val -> builder.header("X-Rate-Limit-Limit", val));
           getXRateLimitRemaining().ifPresent(val -> builder.header("X-Rate-Limit-Remaining", val));
           return builder;
       }
    }

    default CreateMessageResponseHeaders createCreateMessageResponseHeaders() {
        return new CreateMessageResponseHeaders();
    }/**
    * DELETE /{sid} : Deletes a message
    * <ol>
    *    <li>Message deleted (status code 204)</li>
    *    <li>Unauthorized (status code 401)</li>
    *    <li>Forbidden (status code 403)</li>
    *    <li>Internal server error (status code 500)</li>
    *    <li>Rate Limit Exceeded (status code 429)</li>
    *  </ol>
    * 
    * @param sid A unique message SID identifier  a {@link com.twilio.sids.SmsSid}
    * @param apiAuthContext the authentication context  a {@link ApiAuthContext}
    * @param requestContext the request context  a {@link com.twilio.core.request.context.RequestContext}
    * @param responseHeaders a DeleteMessageResponseHeaders container to store response headers
    *
    * @return a {@link CompletionStage} of {@link Either} where left is a {@link TwilioServiceErrorResponse} and right is a {@link Void } possible responses
    */
    default CompletionStage<Either<TwilioServiceErrorResponse, Void>> deleteMessage(
        final com.twilio.sids.SmsSid sid,
        final ApiAuthContext apiAuthContext, 
        final com.twilio.core.request.context.RequestContext requestContext,
        final HelloMessageApi.DeleteMessageResponseHeaders responseHeaders) {
        // TODO: Implement method
        return CompletableFuture.completedStage(Either.left(new TwilioServiceErrorResponse.Builder().withMessage("Method not implemented").withCode(501).withHttpStatusCode(501).build()));
    }
        
    /**
     * DeleteMessageResponseHeaders is intended as a strongly typed container for
     * all the response headers sent by the downstream.
     */
    public static final class DeleteMessageResponseHeaders {
    
    /**
     * The xRateLimitConfig header variable, of type String.
     */
    public String xRateLimitConfig;
    /**
     * The xRateLimitLimit header variable, of type String.
     */
    public String xRateLimitLimit;
    /**
     * The xRateLimitRemaining header variable, of type Integer.
     */
    public Integer xRateLimitRemaining;

    
      /**
       * The xRateLimitConfig response header, of type String.
       *
       * @return the X-Rate-Limit-Config response header
       */
      public Optional<String> getXRateLimitConfig() { 
        return Optional.ofNullable(xRateLimitConfig);
      }

      /**
       * Set the xRateLimitConfig response header.
       *
       * @param xRateLimitConfig the xRateLimitConfig response header
       */
      public void setXRateLimitConfig(final String xRateLimitConfig) {
          this.xRateLimitConfig = xRateLimitConfig;
      }

      /**
       * The xRateLimitLimit response header, of type String.
       *
       * @return the X-Rate-Limit-Limit response header
       */
      public Optional<String> getXRateLimitLimit() { 
        return Optional.ofNullable(xRateLimitLimit);
      }

      /**
       * Set the xRateLimitLimit response header.
       *
       * @param xRateLimitLimit the xRateLimitLimit response header
       */
      public void setXRateLimitLimit(final String xRateLimitLimit) {
          this.xRateLimitLimit = xRateLimitLimit;
      }

      /**
       * The xRateLimitRemaining response header, of type Integer.
       *
       * @return the X-Rate-Limit-Remaining response header
       */
      public Optional<Integer> getXRateLimitRemaining() { 
        return Optional.ofNullable(xRateLimitRemaining);
      }

      /**
       * Set the xRateLimitRemaining response header.
       *
       * @param xRateLimitRemaining the xRateLimitRemaining response header
       */
      public void setXRateLimitRemaining(final Integer xRateLimitRemaining) {
          this.xRateLimitRemaining = xRateLimitRemaining;
      }

        /**
         * Default constructor for DeleteMessageResponseHeaders().
         */
        public DeleteMessageResponseHeaders() {
        }

        /**
         * Using the specified <code>builder</code> assign all non-empty
         * header properties.
         *
         * @param builder a {@link ResponseBuilder} add header variables to
         *
         * @return the {@link ResponseBuilder}
         */
        public ResponseBuilder addHeaders(@NotNull final ResponseBuilder builder) { 
           getXRateLimitConfig().ifPresent(val -> builder.header("X-Rate-Limit-Config", val));
           getXRateLimitLimit().ifPresent(val -> builder.header("X-Rate-Limit-Limit", val));
           getXRateLimitRemaining().ifPresent(val -> builder.header("X-Rate-Limit-Remaining", val));
           return builder;
       }
    }

    default DeleteMessageResponseHeaders createDeleteMessageResponseHeaders() {
        return new DeleteMessageResponseHeaders();
    }/**
    * GET /{sid} : Fetch a message
    * <ol>
    *    <li>Message returned (status code 200)</li>
    *    <li>Unauthorized (status code 401)</li>
    *    <li>Forbidden (status code 403)</li>
    *    <li>Message not found (status code 404)</li>
    *    <li>Internal server error (status code 500)</li>
    *    <li>Rate Limit Exceeded (status code 429)</li>
    *    <li>Not Modified (status code 304)</li>
    *  </ol>
    * 
    * @param sid A unique message SID identifier  a {@link com.twilio.sids.SmsSid}
    * @param apiAuthContext the authentication context  a {@link ApiAuthContext}
    * @param requestContext the request context  a {@link com.twilio.core.request.context.RequestContext}
    * @param conditional a {@link ConditionalRequest} object to use for conditional requests
    * @param responseHeaders a GetMessageResponseHeaders container to store response headers
    *
    * @return a {@link CompletionStage} of {@link Either} where left is a {@link TwilioServiceErrorResponse} and right is a {@link HelloMessageContainer } possible responses
    */
    default CompletionStage<Either<TwilioServiceErrorResponse, HelloMessageContainer>> getMessage(
        final com.twilio.sids.SmsSid sid,
        final ApiAuthContext apiAuthContext, 
        final com.twilio.core.request.context.RequestContext requestContext,
        final ConditionalRequest conditional,
        final HelloMessageApi.GetMessageResponseHeaders responseHeaders) {
        // TODO: Implement method
        return CompletableFuture.completedStage(Either.left(new TwilioServiceErrorResponse.Builder().withMessage("Method not implemented").withCode(501).withHttpStatusCode(501).build()));
    }
        
    /**
     * GetMessageResponseHeaders is intended as a strongly typed container for
     * all the response headers sent by the downstream.
     */
    public static final class GetMessageResponseHeaders {
    
    /**
     * The etag header variable, of type String.
     */
    public String etag;
    /**
     * The xRateLimitConfig header variable, of type String.
     */
    public String xRateLimitConfig;
    /**
     * The xRateLimitLimit header variable, of type String.
     */
    public String xRateLimitLimit;
    /**
     * The xRateLimitRemaining header variable, of type Integer.
     */
    public Integer xRateLimitRemaining;
    /**
     * The eTag header variable, of type String.
     */
    public String eTag;
    /**
     * The cacheControl header variable, of type String.
     */
    public String cacheControl;
    /**
     * The contentLocation header variable, of type String.
     */
    public String contentLocation;
    /**
     * The dATE header variable, of type String.
     */
    public String dATE;
    /**
     * The expires header variable, of type String.
     */
    public String expires;
    /**
     * The vary header variable, of type String.
     */
    public String vary;
    /**
     * The lastModified header variable, of type String.
     */
    public String lastModified;

    
      /**
       * The etag response header, of type String.
       *
       * @return the etag response header
       */
      public Optional<String> getEtag() { 
        return Optional.ofNullable(etag);
      }

      /**
       * Set the etag response header.
       *
       * @param etag the etag response header
       */
      public void setEtag(final String etag) {
          this.etag = etag;
      }

      /**
       * The xRateLimitConfig response header, of type String.
       *
       * @return the X-Rate-Limit-Config response header
       */
      public Optional<String> getXRateLimitConfig() { 
        return Optional.ofNullable(xRateLimitConfig);
      }

      /**
       * Set the xRateLimitConfig response header.
       *
       * @param xRateLimitConfig the xRateLimitConfig response header
       */
      public void setXRateLimitConfig(final String xRateLimitConfig) {
          this.xRateLimitConfig = xRateLimitConfig;
      }

      /**
       * The xRateLimitLimit response header, of type String.
       *
       * @return the X-Rate-Limit-Limit response header
       */
      public Optional<String> getXRateLimitLimit() { 
        return Optional.ofNullable(xRateLimitLimit);
      }

      /**
       * Set the xRateLimitLimit response header.
       *
       * @param xRateLimitLimit the xRateLimitLimit response header
       */
      public void setXRateLimitLimit(final String xRateLimitLimit) {
          this.xRateLimitLimit = xRateLimitLimit;
      }

      /**
       * The xRateLimitRemaining response header, of type Integer.
       *
       * @return the X-Rate-Limit-Remaining response header
       */
      public Optional<Integer> getXRateLimitRemaining() { 
        return Optional.ofNullable(xRateLimitRemaining);
      }

      /**
       * Set the xRateLimitRemaining response header.
       *
       * @param xRateLimitRemaining the xRateLimitRemaining response header
       */
      public void setXRateLimitRemaining(final Integer xRateLimitRemaining) {
          this.xRateLimitRemaining = xRateLimitRemaining;
      }

      /**
       * The eTag response header, of type String.
       *
       * @return the ETag response header
       */
      public Optional<String> getETag() { 
        return Optional.ofNullable(eTag);
      }

      /**
       * Set the eTag response header.
       *
       * @param eTag the eTag response header
       */
      public void setETag(final String eTag) {
          this.eTag = eTag;
      }

      /**
       * The cacheControl response header, of type String.
       *
       * @return the Cache-Control response header
       */
      public Optional<String> getCacheControl() { 
        return Optional.ofNullable(cacheControl);
      }

      /**
       * Set the cacheControl response header.
       *
       * @param cacheControl the cacheControl response header
       */
      public void setCacheControl(final String cacheControl) {
          this.cacheControl = cacheControl;
      }

      /**
       * The contentLocation response header, of type String.
       *
       * @return the Content-Location response header
       */
      public Optional<String> getContentLocation() { 
        return Optional.ofNullable(contentLocation);
      }

      /**
       * Set the contentLocation response header.
       *
       * @param contentLocation the contentLocation response header
       */
      public void setContentLocation(final String contentLocation) {
          this.contentLocation = contentLocation;
      }

      /**
       * The dATE response header, of type String.
       *
       * @return the DATE response header
       */
      public Optional<String> getDATE() { 
        return Optional.ofNullable(dATE);
      }

      /**
       * Set the dATE response header.
       *
       * @param dATE the dATE response header
       */
      public void setDATE(final String dATE) {
          this.dATE = dATE;
      }

      /**
       * The expires response header, of type String.
       *
       * @return the Expires response header
       */
      public Optional<String> getExpires() { 
        return Optional.ofNullable(expires);
      }

      /**
       * Set the expires response header.
       *
       * @param expires the expires response header
       */
      public void setExpires(final String expires) {
          this.expires = expires;
      }

      /**
       * The vary response header, of type String.
       *
       * @return the Vary response header
       */
      public Optional<String> getVary() { 
        return Optional.ofNullable(vary);
      }

      /**
       * Set the vary response header.
       *
       * @param vary the vary response header
       */
      public void setVary(final String vary) {
          this.vary = vary;
      }

      /**
       * The lastModified response header, of type String.
       *
       * @return the Last-Modified response header
       */
      public Optional<String> getLastModified() { 
        return Optional.ofNullable(lastModified);
      }

      /**
       * Set the lastModified response header.
       *
       * @param lastModified the lastModified response header
       */
      public void setLastModified(final String lastModified) {
          this.lastModified = lastModified;
      }

        /**
         * Default constructor for GetMessageResponseHeaders().
         */
        public GetMessageResponseHeaders() {
        }

        /**
         * Using the specified <code>builder</code> assign all non-empty
         * header properties.
         *
         * @param builder a {@link ResponseBuilder} add header variables to
         *
         * @return the {@link ResponseBuilder}
         */
        public ResponseBuilder addHeaders(@NotNull final ResponseBuilder builder) { 
           getEtag().ifPresent(val -> builder.header("etag", val));
           getXRateLimitConfig().ifPresent(val -> builder.header("X-Rate-Limit-Config", val));
           getXRateLimitLimit().ifPresent(val -> builder.header("X-Rate-Limit-Limit", val));
           getXRateLimitRemaining().ifPresent(val -> builder.header("X-Rate-Limit-Remaining", val));
           getETag().ifPresent(val -> builder.header("ETag", val));
           getCacheControl().ifPresent(val -> builder.header("Cache-Control", val));
           getContentLocation().ifPresent(val -> builder.header("Content-Location", val));
           getDATE().ifPresent(val -> builder.header("DATE", val));
           getExpires().ifPresent(val -> builder.header("Expires", val));
           getVary().ifPresent(val -> builder.header("Vary", val));
           getLastModified().ifPresent(val -> builder.header("Last-Modified", val));
           return builder;
       }
    }

    default GetMessageResponseHeaders createGetMessageResponseHeaders() {
        return new GetMessageResponseHeaders();
    }/**
    * GET  : Retrieves messages
    * <ol>
    *    <li>Returned message list (status code 200)</li>
    *    <li>Unauthorized (status code 401)</li>
    *    <li>Forbidden (status code 403)</li>
    *    <li>Internal server error (status code 500)</li>
    *    <li>Rate Limit Exceeded (status code 429)</li>
    *  </ol>
    * 
    * @param from A sender name  a {@link String}
    * @param to A recipient name  a {@link String}
    * @param pageSize Number of results to return at once  a {@link Integer}
    * @param pageToken Opaque token describing which page of results to return  a {@link String}
    * @param apiAuthContext the authentication context  a {@link ApiAuthContext}
    * @param requestContext the request context  a {@link com.twilio.core.request.context.RequestContext}
    * @param responseHeaders a ListMessagesResponseHeaders container to store response headers
    *
    * @return a {@link CompletionStage} of {@link Either} where left is a {@link TwilioServiceErrorResponse} and right is a {@link HelloMessageList } possible responses
    */
    default CompletionStage<Either<TwilioServiceErrorResponse, HelloMessageList>> listMessages(
        final String from,
        final String to,
        final Integer pageSize,
        final String pageToken,
        final ApiAuthContext apiAuthContext, 
        final com.twilio.core.request.context.RequestContext requestContext,
        final HelloMessageApi.ListMessagesResponseHeaders responseHeaders) {
        // TODO: Implement method
        return CompletableFuture.completedStage(Either.left(new TwilioServiceErrorResponse.Builder().withMessage("Method not implemented").withCode(501).withHttpStatusCode(501).build()));
    }
        
    /**
     * ListMessagesResponseHeaders is intended as a strongly typed container for
     * all the response headers sent by the downstream.
     */
    public static final class ListMessagesResponseHeaders {
    
    /**
     * The xRateLimitConfig header variable, of type String.
     */
    public String xRateLimitConfig;
    /**
     * The xRateLimitLimit header variable, of type String.
     */
    public String xRateLimitLimit;
    /**
     * The xRateLimitRemaining header variable, of type Integer.
     */
    public Integer xRateLimitRemaining;

    
      /**
       * The xRateLimitConfig response header, of type String.
       *
       * @return the X-Rate-Limit-Config response header
       */
      public Optional<String> getXRateLimitConfig() { 
        return Optional.ofNullable(xRateLimitConfig);
      }

      /**
       * Set the xRateLimitConfig response header.
       *
       * @param xRateLimitConfig the xRateLimitConfig response header
       */
      public void setXRateLimitConfig(final String xRateLimitConfig) {
          this.xRateLimitConfig = xRateLimitConfig;
      }

      /**
       * The xRateLimitLimit response header, of type String.
       *
       * @return the X-Rate-Limit-Limit response header
       */
      public Optional<String> getXRateLimitLimit() { 
        return Optional.ofNullable(xRateLimitLimit);
      }

      /**
       * Set the xRateLimitLimit response header.
       *
       * @param xRateLimitLimit the xRateLimitLimit response header
       */
      public void setXRateLimitLimit(final String xRateLimitLimit) {
          this.xRateLimitLimit = xRateLimitLimit;
      }

      /**
       * The xRateLimitRemaining response header, of type Integer.
       *
       * @return the X-Rate-Limit-Remaining response header
       */
      public Optional<Integer> getXRateLimitRemaining() { 
        return Optional.ofNullable(xRateLimitRemaining);
      }

      /**
       * Set the xRateLimitRemaining response header.
       *
       * @param xRateLimitRemaining the xRateLimitRemaining response header
       */
      public void setXRateLimitRemaining(final Integer xRateLimitRemaining) {
          this.xRateLimitRemaining = xRateLimitRemaining;
      }

        /**
         * Default constructor for ListMessagesResponseHeaders().
         */
        public ListMessagesResponseHeaders() {
        }

        /**
         * Using the specified <code>builder</code> assign all non-empty
         * header properties.
         *
         * @param builder a {@link ResponseBuilder} add header variables to
         *
         * @return the {@link ResponseBuilder}
         */
        public ResponseBuilder addHeaders(@NotNull final ResponseBuilder builder) { 
           getXRateLimitConfig().ifPresent(val -> builder.header("X-Rate-Limit-Config", val));
           getXRateLimitLimit().ifPresent(val -> builder.header("X-Rate-Limit-Limit", val));
           getXRateLimitRemaining().ifPresent(val -> builder.header("X-Rate-Limit-Remaining", val));
           return builder;
       }
    }

    default ListMessagesResponseHeaders createListMessagesResponseHeaders() {
        return new ListMessagesResponseHeaders();
    }/**
    * PUT /{sid} : Update a message
    * <ol>
    *    <li>Message updated (status code 200)</li>
    *    <li>Invalid parameters (status code 400)</li>
    *    <li>Unauthorized (status code 401)</li>
    *    <li>Forbidden (status code 403)</li>
    *    <li>Message not found (status code 404)</li>
    *    <li>Internal server error (status code 500)</li>
    *    <li>Rate Limit Exceeded (status code 429)</li>
    *    <li>Precondition Failed (status code 412)</li>
    *  </ol>
    * 
    * @param sid A unique message SID identifier  a {@link com.twilio.sids.SmsSid}
    * @param from Sender address  a {@link String}
    * @param to Recipient address  a {@link String}
    * @param message Message body  a {@link String}
    * @param apiAuthContext the authentication context  a {@link ApiAuthContext}
    * @param requestContext the request context  a {@link com.twilio.core.request.context.RequestContext}
    * @param conditional a {@link ConditionalRequest} object to use for conditional requests
    * @param responseHeaders a UpdateMessageResponseHeaders container to store response headers
    *
    * @return a {@link CompletionStage} of {@link Either} where left is a {@link TwilioServiceErrorResponse} and right is a {@link HelloMessageContainer } possible responses
    */
    default CompletionStage<Either<TwilioServiceErrorResponse, HelloMessageContainer>> updateMessage(
        final com.twilio.sids.SmsSid sid,
        final String from,
        final String to,
        final String message,
        final ApiAuthContext apiAuthContext, 
        final com.twilio.core.request.context.RequestContext requestContext,
        final ConditionalRequest conditional,
        final HelloMessageApi.UpdateMessageResponseHeaders responseHeaders) {
        // TODO: Implement method
        return CompletableFuture.completedStage(Either.left(new TwilioServiceErrorResponse.Builder().withMessage("Method not implemented").withCode(501).withHttpStatusCode(501).build()));
    }
        
    /**
     * UpdateMessageResponseHeaders is intended as a strongly typed container for
     * all the response headers sent by the downstream.
     */
    public static final class UpdateMessageResponseHeaders {
    
    /**
     * The xRateLimitConfig header variable, of type String.
     */
    public String xRateLimitConfig;
    /**
     * The xRateLimitLimit header variable, of type String.
     */
    public String xRateLimitLimit;
    /**
     * The xRateLimitRemaining header variable, of type Integer.
     */
    public Integer xRateLimitRemaining;
    /**
     * The eTag header variable, of type String.
     */
    public String eTag;
    /**
     * The lastModified header variable, of type String.
     */
    public String lastModified;

    
      /**
       * The xRateLimitConfig response header, of type String.
       *
       * @return the X-Rate-Limit-Config response header
       */
      public Optional<String> getXRateLimitConfig() { 
        return Optional.ofNullable(xRateLimitConfig);
      }

      /**
       * Set the xRateLimitConfig response header.
       *
       * @param xRateLimitConfig the xRateLimitConfig response header
       */
      public void setXRateLimitConfig(final String xRateLimitConfig) {
          this.xRateLimitConfig = xRateLimitConfig;
      }

      /**
       * The xRateLimitLimit response header, of type String.
       *
       * @return the X-Rate-Limit-Limit response header
       */
      public Optional<String> getXRateLimitLimit() { 
        return Optional.ofNullable(xRateLimitLimit);
      }

      /**
       * Set the xRateLimitLimit response header.
       *
       * @param xRateLimitLimit the xRateLimitLimit response header
       */
      public void setXRateLimitLimit(final String xRateLimitLimit) {
          this.xRateLimitLimit = xRateLimitLimit;
      }

      /**
       * The xRateLimitRemaining response header, of type Integer.
       *
       * @return the X-Rate-Limit-Remaining response header
       */
      public Optional<Integer> getXRateLimitRemaining() { 
        return Optional.ofNullable(xRateLimitRemaining);
      }

      /**
       * Set the xRateLimitRemaining response header.
       *
       * @param xRateLimitRemaining the xRateLimitRemaining response header
       */
      public void setXRateLimitRemaining(final Integer xRateLimitRemaining) {
          this.xRateLimitRemaining = xRateLimitRemaining;
      }

      /**
       * The eTag response header, of type String.
       *
       * @return the ETag response header
       */
      public Optional<String> getETag() { 
        return Optional.ofNullable(eTag);
      }

      /**
       * Set the eTag response header.
       *
       * @param eTag the eTag response header
       */
      public void setETag(final String eTag) {
          this.eTag = eTag;
      }

      /**
       * The lastModified response header, of type String.
       *
       * @return the Last-Modified response header
       */
      public Optional<String> getLastModified() { 
        return Optional.ofNullable(lastModified);
      }

      /**
       * Set the lastModified response header.
       *
       * @param lastModified the lastModified response header
       */
      public void setLastModified(final String lastModified) {
          this.lastModified = lastModified;
      }

        /**
         * Default constructor for UpdateMessageResponseHeaders().
         */
        public UpdateMessageResponseHeaders() {
        }

        /**
         * Using the specified <code>builder</code> assign all non-empty
         * header properties.
         *
         * @param builder a {@link ResponseBuilder} add header variables to
         *
         * @return the {@link ResponseBuilder}
         */
        public ResponseBuilder addHeaders(@NotNull final ResponseBuilder builder) { 
           getXRateLimitConfig().ifPresent(val -> builder.header("X-Rate-Limit-Config", val));
           getXRateLimitLimit().ifPresent(val -> builder.header("X-Rate-Limit-Limit", val));
           getXRateLimitRemaining().ifPresent(val -> builder.header("X-Rate-Limit-Remaining", val));
           getETag().ifPresent(val -> builder.header("ETag", val));
           getLastModified().ifPresent(val -> builder.header("Last-Modified", val));
           return builder;
       }
    }

    default UpdateMessageResponseHeaders createUpdateMessageResponseHeaders() {
        return new UpdateMessageResponseHeaders();
    }
      /**
   * Conditional requests are HTTP requests [RFC7231] that include one or more header fields
   * indicating a precondition to be tested before applying the method semantics to the target
   * resource. This document defines the HTTP/1.1 conditional request mechanisms in terms of the
   * architecture, syntax notation, and conformance criteria defined in [RFC7230].
   */
  public static class ConditionalRequest {
    /** The if-match request header field. */
    public static final String IF_MATCH = "If-Match";
    /** The if-none-match request header field. */
    public static final String IF_NONE_MATCH = "If-None-Match";
    /** The if-modified-since request header field. */
    public static final String IF_MODIFIED_SINCE = "If-Modified-Since";
    /** The if-unmodified-since request header field. */
    public static final String IF_UNMODIFIED_SINCE = "If-Unmodified-Since";
    /** The if-range request header field. */
    public static final String IF_RANGE = "If-Range";

    /**
     * Makes the request method conditional on the recipient origin server either having at least
     * one current representation of the target resource, when the field-value is '*', or having a
     * current representation of the target resource that has an entity-tag matching a member of the
     * list of entity-tags provided in the field-value.
     *
     * <p>Header name is 'If-Match'.
     */
    private final String ifMatch;

    /**
     * Makes the request method conditional on the selected representation's last modification date
     * being earlier than or equal to the date provided in the field-value.
     *
     * <p>Header name is 'If-Modified-Since'.
     */
    private final String ifModifiedSince;

    /**
     * Makes the request method conditional on the selected representation not having an entity-tag
     * matching any of the entity-tags provided in the field-value
     *
     * <p>Header name is 'If-None-Match'.
     */
    private final String ifNoneMatch;

    /**
     * Makes the request method conditional on the selected representation's last modification date
     * being later than the date provided in the field-value.
     *
     * <p>Header name is 'If-Unmodified-Since.'
     */
    private final String ifUnmodifiedSince;

    /**
     * The "If-Range" header field provides a special conditional request mechanism that is similar
     * to the If-Match and If-Unmodified-Since header fields but that instructs the recipient to
     * ignore the Range header field if the validator doesn't match, resulting in transfer of the
     * new selected representation instead of a 412 (Precondition Failed) response. If-Range is
     * defined in Section 3.2 of RFC7233.
     */
    private final String ifRange;

    /**
     * Constructor.
     *
     * @param ifMatch Makes the request method conditional on the recipient origin server either
     *     having at least one current representation of the target resource, when the field-value
     *     is *, or having a current representation of the target resource that has an entity-tag
     *     matching a member of the list of entity-tags provided in the field-value. a {@link
     *     String}
     * @param ifModifiedSince Makes the request method conditional on the selected representation's
     *     last modification date being earlier than or equal to the date provided in the
     *     field-value. a {@link String}
     * @param ifNoneMatch Makes the request method conditional on the selected representation not
     *     having an entity-tag matching any of the entity-tags provided in the field-value. a
     *     {@link String}
     * @param ifUnmodifiedSince Makes the request method conditional on the selected
     *     representation's last modification date being later than the date provided in the
     *     field-value. a {@link String}
     * @param ifRange is similar to the If-Match and If-Unmodified-Since header fields but that
     *     instructs the recipient to ignore the Range header field if the validator doesn't match,
     *     resulting in transfer of the new selected representation instead of a 412 (Precondition
     *     Failed) response.
     */
    public ConditionalRequest(
        final String ifMatch,
        final String ifModifiedSince,
        final String ifNoneMatch,
        final String ifUnmodifiedSince,
        final String ifRange) {
      this.ifMatch = ifMatch;
      this.ifModifiedSince = ifModifiedSince;
      this.ifNoneMatch = ifNoneMatch;
      this.ifUnmodifiedSince = ifUnmodifiedSince;
      this.ifRange = ifRange;
    }

    private ConditionalRequest(final Builder builder) {
      ifMatch = builder.ifMatch;
      ifModifiedSince = builder.ifModifiedSince;
      ifNoneMatch = builder.ifNoneMatch;
      ifUnmodifiedSince = builder.ifUnmodifiedSince;
      ifRange = builder.ifRange;
    }

    /**
      * Create a new Builder by cloning an existing ConditionalRequest.
      *
      * @param copy the ConditionalRequest to clone
      * @return a new Builder
      */
    public static Builder newBuilder(final ConditionalRequest copy) {
      Builder builder = new Builder();
      builder.ifMatch = copy.getIfMatch().orElse(null);
      builder.ifModifiedSince = copy.getIfModifiedSince().orElse(null);
      builder.ifNoneMatch = copy.getIfNoneMatch().orElse(null);
      builder.ifUnmodifiedSince = copy.getIfUnmodifiedSince().orElse(null);
      return builder;
    }

    /**
     * Set Request headers on the specified Endpoint.
     *
     * @param endpoint the endpoint to add the headers to
     */
    public void setHeaders(final Endpoint endpoint) {
      if (nonNull(ifMatch) && !ifMatch.isEmpty()) {
        endpoint.header(IF_MATCH, ifMatch);
      }

      if (nonNull(ifNoneMatch) && !ifNoneMatch.isEmpty()) {
        endpoint.header(IF_NONE_MATCH, ifNoneMatch);
      }

      if (nonNull(ifModifiedSince) && !ifModifiedSince.isEmpty()) {
        endpoint.header(IF_MODIFIED_SINCE, ifModifiedSince);
      }

      if (nonNull(ifUnmodifiedSince) && !ifUnmodifiedSince.isEmpty()) {
        endpoint.header(IF_UNMODIFIED_SINCE, ifUnmodifiedSince);
      }

      if (nonNull(ifRange) && !ifRange.isEmpty()) {
        endpoint.header(IF_RANGE, ifRange);
      }
    }

    /**
     * Get the value of the ifMatch property.
     *
     * @return an {@link Optional} of {@link String} representing the value of the ifMatch property
     */
    public Optional<String> getIfMatch() {
      return Optional.of(ifMatch);
    }

    /**
     * Get the value of the ifModifiedSince property.
     *
     * @return an {@link Optional} of {@link String} representing the value of the ifModifiedSince
     *     property
     */
    public Optional<String> getIfModifiedSince() {
      return Optional.of(ifModifiedSince);
    }

   /**
     * Get the value of the ifNoneMatch property.
     *
     * @return an {@link Optional} of {@link String} representing the value of the ifNoneMatch
     *     property
     */
    public Optional<String> getIfNoneMatch() {
      return Optional.of(ifNoneMatch);
    }

    /**
     * Get the value of the ifUnmodifiedSince property.
     *
     * @return an {@link Optional} of {@link String} representing the value of the ifUnmodifiedSince
     *     property
     */
    public Optional<String> getIfUnmodifiedSince() {
      return Optional.of(ifUnmodifiedSince);
    }

    /**
     * Get the value of the ifRange property.
     *
     * @return an {@link Optional} of {@link String} representing the value of the ifRange property
     */
    public Optional<String> getIfRange() {
      return Optional.of(ifRange);
    }

    @Override
    public boolean equals(final Object o) {
      if (this == o) return true;
      if (!(o instanceof ConditionalRequest)) return false;
      final ConditionalRequest that = (ConditionalRequest) o;
      return Objects.equals(ifMatch, that.ifMatch)
          && Objects.equals(ifModifiedSince, that.ifModifiedSince)
          && Objects.equals(ifNoneMatch, that.ifNoneMatch)
          && Objects.equals(ifUnmodifiedSince, that.ifUnmodifiedSince)
          && Objects.equals(ifRange, that.ifRange);
    }

    @Override
    public int hashCode() {
      return Objects.hash(ifMatch, ifModifiedSince, ifNoneMatch, ifUnmodifiedSince, ifRange);
    }

    @Override
    public String toString() {
      return "ConditionalRequest{"
          + "ifMatch='"
          + ifMatch
          + '\''
          + ", ifModifiedSince='"
          + ifModifiedSince
          + '\''
          + ", ifNoneMatch='"
          + ifNoneMatch
          + '\''
          + ", ifUnmodifiedSince='"
          + ifUnmodifiedSince
          + ", ifRange='"
          + ifRange
          + '\''
          + '}';
    }

    /** {@code ConditionalRequest} builder static inner class. */
    public static final class Builder {
      public String ifRange;
      private String ifMatch;
      private String ifModifiedSince;
      private String ifNoneMatch;
      private String ifUnmodifiedSince;

      private Builder() {}

      public static Builder newBuilder() {
        return new Builder();
      }

      /**
       * Sets the {@code ifMatch} and returns a reference to this Builder enabling method chaining.
       *
       * @param ifMatch the {@code ifMatch} to set
       * @return a reference to this Builder
       */
      public Builder withIfMatch(final String ifMatch) {
        this.ifMatch = ifMatch;
        return this;
      }

      /**
       * Sets the {@code ifModifiedSince} and returns a reference to this Builder enabling method
       * chaining.
       *
       * @param ifModifiedSince the {@code ifModifiedSince} to set
       * @return a reference to this Builder
       */
      public Builder withIfModifiedSince(final String ifModifiedSince) {
        this.ifModifiedSince = ifModifiedSince;
        return this;
      }

      /**
       * Sets the {@code ifNoneMatch} and returns a reference to this Builder enabling method
       * chaining.
       *
       * @param ifNoneMatch the {@code ifNoneMatch} to set
       * @return a reference to this Builder
       */
      public Builder withIfNoneMatch(final String ifNoneMatch) {
        this.ifNoneMatch = ifNoneMatch;
        return this;
      }

      /**
       * Sets the {@code ifUnmodifiedSince} and returns a reference to this Builder enabling method
       * chaining.
       *
       * @param ifUnmodifiedSince the {@code ifUnmodifiedSince} to set
       * @return a reference to this Builder
       */
      public Builder withIfUnmodifiedSince(final String ifUnmodifiedSince) {
        this.ifUnmodifiedSince = ifUnmodifiedSince;
        return this;
      }

      /**
       * Sets the {@code ifRange} and returns a reference to this Builder enabling method chaining.
       *
       * @param ifRange the {@code ifRange} to set
       * @return a reference to this Builder
       */
      public Builder withIfRange(final String ifRange) {
        this.ifRange = ifRange;
        return this;
      }

      /**
       * Returns a {@code ConditionalRequest} built from the parameters previously set.
       *
       * @return a {@code ConditionalRequest} built with parameters of this {@code
       *         ConditionalRequest.Builder}
       */
      public ConditionalRequest build() {
        return new ConditionalRequest(this);
      }
    }
  }

    /**
     * Create a conditional request object.
     *
     * @param ifMatch the {@code ifMatch} header
     * @param ifModifiedSince the {@code ifModifiedSince} header
     * @param ifNoneMatch the {@code ifNoneMatch} header
     * @param ifUnmodifiedSince the {@code ifUnmodifiedSince} header
     * @param ifRange the {@code ifRange} header
     *
     * @return a conditional request object
     */
    default ConditionalRequest createConditional(String ifMatch, String ifModifiedSince, String ifNoneMatch, String ifUnmodifiedSince, String ifRange) {
      return new ConditionalRequest(ifMatch, ifModifiedSince, ifNoneMatch, ifUnmodifiedSince, ifRange);
    }
}
